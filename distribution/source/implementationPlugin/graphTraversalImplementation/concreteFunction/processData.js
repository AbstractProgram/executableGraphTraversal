"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.returnDataItemKey = returnDataItemKey;exports.timeout = timeout;exports.executeScriptSpawn = executeScriptSpawn;exports.executeScriptSpawnIgnoreError = executeScriptSpawnIgnoreError;exports.executeScriptSpawnAsynchronous = executeScriptSpawnAsynchronous;exports.executeShellscriptFile = executeShellscriptFile;var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));var _child_process = require("child_process");
var _path = _interopRequireDefault(require("path"));

async function returnDataItemKey({ node }) {var _node$properties;
  let processedData = `${(_node$properties = node.properties) === null || _node$properties === void 0 ? void 0 : _node$properties.name}`;
  return processedData;
}


async function timeout({ node }) {var _node$properties2, _node$properties3;
  if (typeof ((_node$properties2 = node.properties) === null || _node$properties2 === void 0 ? void 0 : _node$properties2.timerDelay) != 'number') throw new Error('• DataItem must have a delay value.');
  let delay = (_node$properties3 = node.properties) === null || _node$properties3 === void 0 ? void 0 : _node$properties3.timerDelay;
  return await new Promise((resolve, reject) =>
  setTimeout(() => {var _node$properties4;

    resolve((_node$properties4 = node.properties) === null || _node$properties4 === void 0 ? void 0 : _node$properties4.name);
  }, delay));

}









let message = ` _____                          _        
| ____|__  __ ___   ___  _   _ | |_  ___ 
|  _|  \\ \\/ // _ \\ / __|| | | || __|/ _ \\
| |___  >  <|  __/| (__ | |_| || |_|  __/    
|_____|/_/\\_\\\\___| \\___| \\__,_| \\__|\\___|`;
const rootPath = _path.default.normalize(_path.default.join(__dirname, '../../../../'));

async function executeScriptSpawn({ node, resourceNode }) {
  let childProcess;
  try {
    console.log(message);
    console.log(`\x1b[45m%s\x1b[0m`, `${node.command} ${node.argument.join(' ')}`);
    childProcess = (0, _child_process.spawnSync)(node.command, node.argument, JSON.stringify(node.option));
    if (childProcess.status > 0) throw childProcess.error;
  } catch (error) {
    process.exit(childProcess.status);
  }

}

async function executeScriptSpawnIgnoreError({ node, resourceNode }) {
  let childProcess;
  try {
    console.log(message);
    console.log(`\x1b[45m%s\x1b[0m`, `${node.command} ${node.argument.join(' ')}`);
    childProcess = (0, _child_process.spawnSync)(node.command, node.argument, JSON.stringify(node.option));
    if (childProcess.status > 0) throw childProcess.error;
  } catch (error) {
    console.log(childProcess.status);
  }

}

async function executeScriptSpawnAsynchronous({ node, resourceNode }) {
  let childProcess;
  try {
    console.log(message);
    console.log(`\x1b[45m%s\x1b[0m`, `${node.command} ${node.argument.join(' ')}`);
    childProcess = (0, _child_process.spawn)(node.command, node.argument, JSON.stringify(node.option));
    if (childProcess.status > 0) throw childProcess.error;
  } catch (error) {
    process.exit(childProcess.status);
  }

}

async function executeShellscriptFile({ node, resourceNode }) {
  try {
    console.log(message);
    console.log(`\x1b[45m%s\x1b[0m`, `shellscript path: ${resourceNode.properties.path}`);
    let absolutePath = _path.default.join('/', rootPath, resourceNode.properties.path);
    (0, _child_process.execSync)(`sh ${absolutePath}`, { cwd: _path.default.dirname(absolutePath), shell: true, stdio: ['inherit', 'inherit', 'inherit'] });
  } catch (error) {
    throw error;
    process.exit(1);
  }

  return null;
}


























async function initializeNestedUnit({ nestedUnitKey, additionalChildNestedUnit = [], pathPointerKey = null }) {


  let view = await nestedUnitInstance.loopInsertionPoint({ type: 'aggregateIntoTemplateObject' });

  assert(this.portAppInstance.config.clientSidePath, "• clientSidePath cannot be undefined. i.e. previous middlewares should've set it");
  let templatePath = _path.default.join(this.portAppInstance.config.clientSidePath, unitInstance.file.filePath);
  let renderedContent;
  switch (unitInstance.processDataImplementation) {
    default:
    case 'underscoreRendering':
      renderedContent = await this.underscoreRendering({ templatePath, view });
      break;}


  switch (unitInstance.processRenderedContent) {
    case 'wrapJsTag':
      renderedContent = `<script type="module" async>${renderedContent}</script>`;
      break;
    default:}


  return renderedContent;
}

async function underscoreRendering({ templatePath, view }) {

  let templateString = await filesystem.readFileSync(templatePath, 'utf-8');

  const templateArgument = {
    templateController: this,
    context: this.portAppInstance.context,
    Application,
    argument: {} };

  let renderedContent = underscore.template(templateString)(
  Object.assign(
  {},
  templateArgument,
  { view, templateArgument }));


  return renderedContent;
}

function renderedContentString(viewName, viewObject) {

  if (viewObject[viewName] && Array.isArray(viewObject[viewName])) {
    return viewObject[viewName].join('');
  }
}

let traversePort = async function aggregateIntoTemplateObject() {
  let view = {};
  if (this.insertionPoint) {
    for (let insertionPoint of this.insertionPoint) {
      let children = await this.filterAndOrderChildren({ insertionPointKey: insertionPoint.key });
      let subsequent = await this.initializeInsertionPoint({ insertionPoint, children });
      if (!(insertionPoint.name in view)) view[insertionPoint.name] = [];
      Array.prototype.push.apply(view[insertionPoint.name], subsequent);
    }
  }
  return view;
};











































































let schema = () => {



















  const { add, execute, conditional, executionLevel } = require('@dependency/commonPattern/source/decoratorUtility.js');
  function schema({ thisArg }) {var _dec, _obj;


    let self = (_dec =
    executionLevel(), (_obj = {
      async initializeNestedUnit({ nestedUnitKey, additionalChildNestedUnit = [], pathPointerKey = null, parent = this, argument = {} }) {


        if (this.executionLevel == 'topLevel') {
          nestedUnitInstance.requestOption = this.portAppInstance.context.request.body;
        } else {

          let fieldArray = parent.requestOption.field;
          if (fieldArray && fieldArray.length == 0 || !fieldArray) {
            nestedUnitInstance.requestOption = {};
          } else if (fieldArray) {
            nestedUnitInstance.requestOption = fieldArray.find(field => field.fieldName == unitInstance.fieldName);
          }
        }


        if (!nestedUnitInstance.requestOption) return;
        nestedUnitInstance.dataset = await unitInstance.resolveDataset({ parentResult: argument.dataset || parent.dataset });

        if (this.portAppInstance.context.request.body.schemaMode == 'nonStrict') {


        } else {
          assert.notEqual(nestedUnitInstance.dataset, undefined, `• returned dataset cannot be undefined for fieldName: ${unitInstance.fieldName}.`);
        }


        let datasetHandling;
        if (Array.isArray(nestedUnitInstance.dataset) && nestedUnitInstance.children && nestedUnitInstance.children.length > 0) {

          datasetHandling = 'sequence';
        } else if (typeof nestedUnitInstance.dataset == 'object' && nestedUnitInstance.children && nestedUnitInstance.children.length > 0) {

          datasetHandling = 'nested';
        } else {

          datasetHandling = 'nonNested';
        }


        let object = {};
        switch (datasetHandling) {
          case 'sequence':
            let promiseArray = nestedUnitInstance.dataset.map(document => {
              let argument = {};
              argument['dataset'] = document;
              return nestedUnitInstance.loopInsertionPoint({ type: 'aggregateIntoContentArray', argument });
            });
            let subsequentDatasetArray = await Promise.all(promiseArray);
            object[unitInstance.fieldName] = subsequentDatasetArray.map((subsequentDataset, index) => {
              return this.formatDatasetOfNestedType({
                subsequentDataset,
                dataset: nestedUnitInstance.dataset[index],
                option: {
                  extrafield: nestedUnitInstance.requestOption.extrafield } });


            });

            break;
          case 'nested':
            let subsequentDataset = await nestedUnitInstance.loopInsertionPoint({ type: 'aggregateIntoContentArray' });
            object[unitInstance.fieldName] = this.formatDatasetOfNestedType({
              subsequentDataset,
              dataset: nestedUnitInstance.dataset,
              option: {
                extrafield: nestedUnitInstance.requestOption.extrafield } });



            break;
          default:
          case 'nonNested':

            object[unitInstance.fieldName] = nestedUnitInstance.dataset;

            break;}




        return object;
      },

      formatDatasetOfNestedType({ subsequentDataset, dataset, option }) {
        let object = {};
        subsequentDataset.forEach(field => {
          object = Object.assign(object, field);
        });
        if (option.extrafield) {

          object = Object.assign(dataset, object);
        }
        return object;
      } }, ((0, _applyDecoratedDescriptor2.default)(_obj, "initializeNestedUnit", [_dec], Object.getOwnPropertyDescriptor(_obj, "initializeNestedUnit"), _obj)), _obj));


    Object.keys(self).forEach(function (key) {
      self[key] = self[key].bind(thisArg);
    }, {});
    return self;
  }

  async function resolveDataset({
    parentResult = null })

  {

    let dataset;
    const algorithm = this.file.algorithm;
    switch (
    algorithm.type) {

      case 'file':
      default:
        {
          let module = require(algorithm.path).default;
          if (typeof module !== 'function') module = module.default;
          let resolver = module();
          let resolverArgument = Object.assign(...[this.args, algorithm.argument].filter(Boolean));
          dataset = await resolver({
            portClassInstance: this.portAppInstance,
            args: resolverArgument,
            parentResult });

        }
        break;}


    return dataset;
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NvdXJjZS9pbXBsZW1lbnRhdGlvblBsdWdpbi9ncmFwaFRyYXZlcnNhbEltcGxlbWVudGF0aW9uL2NvbmNyZXRlRnVuY3Rpb24vcHJvY2Vzc0RhdGEuanMiXSwibmFtZXMiOlsicmV0dXJuRGF0YUl0ZW1LZXkiLCJub2RlIiwicHJvY2Vzc2VkRGF0YSIsInByb3BlcnRpZXMiLCJuYW1lIiwidGltZW91dCIsInRpbWVyRGVsYXkiLCJFcnJvciIsImRlbGF5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwibWVzc2FnZSIsInJvb3RQYXRoIiwicGF0aCIsIm5vcm1hbGl6ZSIsImpvaW4iLCJfX2Rpcm5hbWUiLCJleGVjdXRlU2NyaXB0U3Bhd24iLCJyZXNvdXJjZU5vZGUiLCJjaGlsZFByb2Nlc3MiLCJjb25zb2xlIiwibG9nIiwiY29tbWFuZCIsImFyZ3VtZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9wdGlvbiIsInN0YXR1cyIsImVycm9yIiwicHJvY2VzcyIsImV4aXQiLCJleGVjdXRlU2NyaXB0U3Bhd25JZ25vcmVFcnJvciIsImV4ZWN1dGVTY3JpcHRTcGF3bkFzeW5jaHJvbm91cyIsImV4ZWN1dGVTaGVsbHNjcmlwdEZpbGUiLCJhYnNvbHV0ZVBhdGgiLCJjd2QiLCJkaXJuYW1lIiwic2hlbGwiLCJzdGRpbyIsImluaXRpYWxpemVOZXN0ZWRVbml0IiwibmVzdGVkVW5pdEtleSIsImFkZGl0aW9uYWxDaGlsZE5lc3RlZFVuaXQiLCJwYXRoUG9pbnRlcktleSIsInZpZXciLCJuZXN0ZWRVbml0SW5zdGFuY2UiLCJsb29wSW5zZXJ0aW9uUG9pbnQiLCJ0eXBlIiwiYXNzZXJ0IiwicG9ydEFwcEluc3RhbmNlIiwiY29uZmlnIiwiY2xpZW50U2lkZVBhdGgiLCJ0ZW1wbGF0ZVBhdGgiLCJ1bml0SW5zdGFuY2UiLCJmaWxlIiwiZmlsZVBhdGgiLCJyZW5kZXJlZENvbnRlbnQiLCJwcm9jZXNzRGF0YUltcGxlbWVudGF0aW9uIiwidW5kZXJzY29yZVJlbmRlcmluZyIsInByb2Nlc3NSZW5kZXJlZENvbnRlbnQiLCJ0ZW1wbGF0ZVN0cmluZyIsImZpbGVzeXN0ZW0iLCJyZWFkRmlsZVN5bmMiLCJ0ZW1wbGF0ZUFyZ3VtZW50IiwidGVtcGxhdGVDb250cm9sbGVyIiwiY29udGV4dCIsIkFwcGxpY2F0aW9uIiwidW5kZXJzY29yZSIsInRlbXBsYXRlIiwiT2JqZWN0IiwiYXNzaWduIiwicmVuZGVyZWRDb250ZW50U3RyaW5nIiwidmlld05hbWUiLCJ2aWV3T2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwidHJhdmVyc2VQb3J0IiwiYWdncmVnYXRlSW50b1RlbXBsYXRlT2JqZWN0IiwiaW5zZXJ0aW9uUG9pbnQiLCJjaGlsZHJlbiIsImZpbHRlckFuZE9yZGVyQ2hpbGRyZW4iLCJpbnNlcnRpb25Qb2ludEtleSIsImtleSIsInN1YnNlcXVlbnQiLCJpbml0aWFsaXplSW5zZXJ0aW9uUG9pbnQiLCJwcm90b3R5cGUiLCJwdXNoIiwiYXBwbHkiLCJzY2hlbWEiLCJhZGQiLCJleGVjdXRlIiwiY29uZGl0aW9uYWwiLCJleGVjdXRpb25MZXZlbCIsInJlcXVpcmUiLCJ0aGlzQXJnIiwic2VsZiIsInBhcmVudCIsInJlcXVlc3RPcHRpb24iLCJyZXF1ZXN0IiwiYm9keSIsImZpZWxkQXJyYXkiLCJmaWVsZCIsImxlbmd0aCIsImZpbmQiLCJmaWVsZE5hbWUiLCJkYXRhc2V0IiwicmVzb2x2ZURhdGFzZXQiLCJwYXJlbnRSZXN1bHQiLCJzY2hlbWFNb2RlIiwibm90RXF1YWwiLCJ1bmRlZmluZWQiLCJkYXRhc2V0SGFuZGxpbmciLCJvYmplY3QiLCJwcm9taXNlQXJyYXkiLCJtYXAiLCJkb2N1bWVudCIsInN1YnNlcXVlbnREYXRhc2V0QXJyYXkiLCJhbGwiLCJzdWJzZXF1ZW50RGF0YXNldCIsImluZGV4IiwiZm9ybWF0RGF0YXNldE9mTmVzdGVkVHlwZSIsImV4dHJhZmllbGQiLCJmb3JFYWNoIiwia2V5cyIsImJpbmQiLCJhbGdvcml0aG0iLCJtb2R1bGUiLCJkZWZhdWx0IiwicmVzb2x2ZXIiLCJyZXNvbHZlckFyZ3VtZW50IiwiYXJncyIsImZpbHRlciIsIkJvb2xlYW4iLCJwb3J0Q2xhc3NJbnN0YW5jZSJdLCJtYXBwaW5ncyI6ImtsQkFBQTtBQUNBOztBQUVPLGVBQWVBLGlCQUFmLENBQWlDLEVBQUVDLElBQUYsRUFBakMsRUFBMkM7QUFDaEQsTUFBSUMsYUFBYSxHQUFJLEdBQUQsb0JBQUdELElBQUksQ0FBQ0UsVUFBUixxREFBRyxpQkFBaUJDLElBQUssRUFBN0M7QUFDQSxTQUFPRixhQUFQO0FBQ0Q7OztBQUdNLGVBQWVHLE9BQWYsQ0FBdUIsRUFBRUosSUFBRixFQUF2QixFQUFpQztBQUN0QyxNQUFJLDZCQUFPQSxJQUFJLENBQUNFLFVBQVosc0RBQU8sa0JBQWlCRyxVQUF4QixLQUFzQyxRQUExQyxFQUFvRCxNQUFNLElBQUlDLEtBQUosQ0FBVSxxQ0FBVixDQUFOO0FBQ3BELE1BQUlDLEtBQUssd0JBQUdQLElBQUksQ0FBQ0UsVUFBUixzREFBRyxrQkFBaUJHLFVBQTdCO0FBQ0EsU0FBTyxNQUFNLElBQUlHLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVY7QUFDdkJDLEVBQUFBLFVBQVUsQ0FBQyxNQUFNOztBQUVmRixJQUFBQSxPQUFPLHNCQUFDVCxJQUFJLENBQUNFLFVBQU4sc0RBQUMsa0JBQWlCQyxJQUFsQixDQUFQO0FBQ0QsR0FIUyxFQUdQSSxLQUhPLENBREMsQ0FBYjs7QUFNRDs7Ozs7Ozs7OztBQVVELElBQUlLLE9BQU8sR0FBSTs7OztpREFBZjtBQUtBLE1BQU1DLFFBQVEsR0FBR0MsY0FBS0MsU0FBTCxDQUFlRCxjQUFLRSxJQUFMLENBQVVDLFNBQVYsRUFBcUIsY0FBckIsQ0FBZixDQUFqQjs7QUFFTyxlQUFlQyxrQkFBZixDQUFrQyxFQUFFbEIsSUFBRixFQUFRbUIsWUFBUixFQUFsQyxFQUEwRDtBQUMvRCxNQUFJQyxZQUFKO0FBQ0EsTUFBSTtBQUNGQyxJQUFBQSxP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QUFDckcsUUFBdEIsRUFBZ0MyRyxNQUFoQyxDQUF1Q0MsT0FBdkMsQ0FBakIsQ0FBdkI7QUFDQTNCLFVBQUFBLE9BQU8sR0FBRyxNQUFNdUIsUUFBUSxDQUFDO0FBQ3ZCSyxZQUFBQSxpQkFBaUIsRUFBRSxLQUFLcEYsZUFERDtBQUV2QmlGLFlBQUFBLElBQUksRUFBRUQsZ0JBRmlCO0FBR3ZCdEIsWUFBQUEsWUFIdUIsRUFBRCxDQUF4Qjs7QUFLRDtBQUNELGNBaEJKOzs7QUFtQkEsV0FBT0YsT0FBUDtBQUNEO0FBQ0YsQ0E3SkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjLCBleGVjU3luYywgc3Bhd24sIHNwYXduU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0dXJuRGF0YUl0ZW1LZXkoeyBub2RlIH0pIHtcbiAgbGV0IHByb2Nlc3NlZERhdGEgPSBgJHtub2RlLnByb3BlcnRpZXM/Lm5hbWV9YFxuICByZXR1cm4gcHJvY2Vzc2VkRGF0YVxufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiBkZWxheXMgcHJvbWlzZXMgZm9yIHRlc3RpbmcgYGl0ZXJhdGVDb25uZWN0aW9uYCBvZiBwcm9taXNlcyBlLmcuIGBhbGxQcm9taXNlYCwgYHJhY2VGaXJzdFByb21pc2VgLCBldGMuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGltZW91dCh7IG5vZGUgfSkge1xuICBpZiAodHlwZW9mIG5vZGUucHJvcGVydGllcz8udGltZXJEZWxheSAhPSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCfigKIgRGF0YUl0ZW0gbXVzdCBoYXZlIGEgZGVsYXkgdmFsdWUuJylcbiAgbGV0IGRlbGF5ID0gbm9kZS5wcm9wZXJ0aWVzPy50aW1lckRlbGF5XG4gIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coYCR7ZGVsYXl9bXMgcGFzc2VkIGZvciBrZXkgJHtub2RlLmtleX0uYCkgLy8gZGVidWdcbiAgICAgIHJlc29sdmUobm9kZS5wcm9wZXJ0aWVzPy5uYW1lKVxuICAgIH0sIGRlbGF5KSxcbiAgKVxufVxuXG4vKlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfICAgICAgX19fX18gICAgICAgICBfICAgICBfX19fICAgICAgICAgICAgXyAgICAgICBfICAgXG4gIF9fX19fICBfX19fXyAgX19fIF8gICBffCB8XyBfX3xfICAgX3xfIF8gX19ffCB8IF9fLyBfX198ICBfX18gXyBfXyhfKV8gX18gfCB8XyBcbiAvIF8gXFwgXFwvIC8gXyBcXC8gX198IHwgfCB8IF9fLyBfIFxcfCB8LyBfYCAvIF9ffCB8LyAvXFxfX18gXFwgLyBfX3wgJ19ffCB8ICdfIFxcfCBfX3xcbnwgIF9fLz4gIDwgIF9fLyAoX198IHxffCB8IHx8ICBfXy98IHwgKF98IFxcX18gXFwgICA8ICBfX18pIHwgKF9ffCB8ICB8IHwgfF8pIHwgfF8gXG5cXF9fXy9fL1xcX1xcX19ffFxcX19ffFxcX18sX3xcXF9fXFxfX198fF98XFxfXyxffF9fXy9ffFxcX1xcfF9fX18vIFxcX19ffF98ICB8X3wgLl9fLyBcXF9ffFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF98ICAgICAgICBcbiovXG5sZXQgbWVzc2FnZSA9IGAgX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgIF8gICAgICAgIFxufCBfX19ffF9fICBfXyBfX18gICBfX18gIF8gICBfIHwgfF8gIF9fXyBcbnwgIF98ICBcXFxcIFxcXFwvIC8vIF8gXFxcXCAvIF9ffHwgfCB8IHx8IF9ffC8gXyBcXFxcXG58IHxfX18gID4gIDx8ICBfXy98IChfXyB8IHxffCB8fCB8X3wgIF9fLyAgICBcbnxfX19fX3wvXy9cXFxcX1xcXFxcXFxcX19ffCBcXFxcX19ffCBcXFxcX18sX3wgXFxcXF9ffFxcXFxfX198YFxuY29uc3Qgcm9vdFBhdGggPSBwYXRoLm5vcm1hbGl6ZShwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vLi4vLi4vLi4vJykpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlU2NyaXB0U3Bhd24oeyBub2RlLCByZXNvdXJjZU5vZGUgfSkge1xuICBsZXQgY2hpbGRQcm9jZXNzXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2cobWVzc2FnZSlcbiAgICBjb25zb2xlLmxvZyhgXFx4MWJbNDVtJXNcXHgxYlswbWAsIGAke25vZGUuY29tbWFuZH0gJHtub2RlLmFyZ3VtZW50LmpvaW4oJyAnKX1gKVxuICAgIGNoaWxkUHJvY2VzcyA9IHNwYXduU3luYyhub2RlLmNvbW1hbmQsIG5vZGUuYXJndW1lbnQsIEpTT04uc3RyaW5naWZ5KG5vZGUub3B0aW9uKSlcbiAgICBpZiAoY2hpbGRQcm9jZXNzLnN0YXR1cyA+IDApIHRocm93IGNoaWxkUHJvY2Vzcy5lcnJvclxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHByb2Nlc3MuZXhpdChjaGlsZFByb2Nlc3Muc3RhdHVzKVxuICB9XG4gIC8vIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKSAvLyB3YWl0IHggc2Vjb25kcyBiZWZvcmUgbmV4dCBzY3JpcHQgZXhlY3V0aW9uIC8vIGltcG9ydGFudCB0byBwcmV2ZW50ICd1bmFibGUgdG8gcmUtb3BlbiBzdGRpbicgZXJyb3IgYmV0d2VlbiBzaGVsbHMuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlU2NyaXB0U3Bhd25JZ25vcmVFcnJvcih7IG5vZGUsIHJlc291cmNlTm9kZSB9KSB7XG4gIGxldCBjaGlsZFByb2Nlc3NcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhtZXNzYWdlKVxuICAgIGNvbnNvbGUubG9nKGBcXHgxYls0NW0lc1xceDFiWzBtYCwgYCR7bm9kZS5jb21tYW5kfSAke25vZGUuYXJndW1lbnQuam9pbignICcpfWApXG4gICAgY2hpbGRQcm9jZXNzID0gc3Bhd25TeW5jKG5vZGUuY29tbWFuZCwgbm9kZS5hcmd1bWVudCwgSlNPTi5zdHJpbmdpZnkobm9kZS5vcHRpb24pKVxuICAgIGlmIChjaGlsZFByb2Nlc3Muc3RhdHVzID4gMCkgdGhyb3cgY2hpbGRQcm9jZXNzLmVycm9yXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coY2hpbGRQcm9jZXNzLnN0YXR1cylcbiAgfVxuICAvLyBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSkgLy8gd2FpdCB4IHNlY29uZHMgYmVmb3JlIG5leHQgc2NyaXB0IGV4ZWN1dGlvbiAvLyBpbXBvcnRhbnQgdG8gcHJldmVudCAndW5hYmxlIHRvIHJlLW9wZW4gc3RkaW4nIGVycm9yIGJldHdlZW4gc2hlbGxzLlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVNjcmlwdFNwYXduQXN5bmNocm9ub3VzKHsgbm9kZSwgcmVzb3VyY2VOb2RlIH0pIHtcbiAgbGV0IGNoaWxkUHJvY2Vzc1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpXG4gICAgY29uc29sZS5sb2coYFxceDFiWzQ1bSVzXFx4MWJbMG1gLCBgJHtub2RlLmNvbW1hbmR9ICR7bm9kZS5hcmd1bWVudC5qb2luKCcgJyl9YClcbiAgICBjaGlsZFByb2Nlc3MgPSBzcGF3bihub2RlLmNvbW1hbmQsIG5vZGUuYXJndW1lbnQsIEpTT04uc3RyaW5naWZ5KG5vZGUub3B0aW9uKSlcbiAgICBpZiAoY2hpbGRQcm9jZXNzLnN0YXR1cyA+IDApIHRocm93IGNoaWxkUHJvY2Vzcy5lcnJvclxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHByb2Nlc3MuZXhpdChjaGlsZFByb2Nlc3Muc3RhdHVzKVxuICB9XG4gIC8vIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKSAvLyB3YWl0IHggc2Vjb25kcyBiZWZvcmUgbmV4dCBzY3JpcHQgZXhlY3V0aW9uIC8vIGltcG9ydGFudCB0byBwcmV2ZW50ICd1bmFibGUgdG8gcmUtb3BlbiBzdGRpbicgZXJyb3IgYmV0d2VlbiBzaGVsbHMuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlU2hlbGxzY3JpcHRGaWxlKHsgbm9kZSwgcmVzb3VyY2VOb2RlIH0pIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhtZXNzYWdlKVxuICAgIGNvbnNvbGUubG9nKGBcXHgxYls0NW0lc1xceDFiWzBtYCwgYHNoZWxsc2NyaXB0IHBhdGg6ICR7cmVzb3VyY2VOb2RlLnByb3BlcnRpZXMucGF0aH1gKVxuICAgIGxldCBhYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4oJy8nLCByb290UGF0aCwgcmVzb3VyY2VOb2RlLnByb3BlcnRpZXMucGF0aClcbiAgICBleGVjU3luYyhgc2ggJHthYnNvbHV0ZVBhdGh9YCwgeyBjd2Q6IHBhdGguZGlybmFtZShhYnNvbHV0ZVBhdGgpLCBzaGVsbDogdHJ1ZSwgc3RkaW86IFsnaW5oZXJpdCcsICdpbmhlcml0JywgJ2luaGVyaXQnXSB9KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9yXG4gICAgcHJvY2Vzcy5leGl0KDEpXG4gIH1cbiAgLy8gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpIC8vIHdhaXQgeCBzZWNvbmRzIGJlZm9yZSBuZXh0IHNjcmlwdCBleGVjdXRpb24gLy8gaW1wb3J0YW50IHRvIHByZXZlbnQgJ3VuYWJsZSB0byByZS1vcGVuIHN0ZGluJyBlcnJvciBiZXR3ZWVuIHNoZWxscy5cbiAgcmV0dXJuIG51bGxcbn1cblxuLypcbiAgIF9fICBfXyBfICAgICBfICAgICBfIF8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICB8ICBcXC8gIChfKSBfX3wgfCBfX3wgfCB8IF9fX19fICAgICAgX19fXyBfIF8gX18gX19fIFxuICB8IHxcXC98IHwgfC8gX2AgfC8gX2AgfCB8LyBfIFxcIFxcIC9cXCAvIC8gX2AgfCAnX18vIF8gXFxcbiAgfCB8ICB8IHwgfCAoX3wgfCAoX3wgfCB8ICBfXy9cXCBWICBWIC8gKF98IHwgfCB8ICBfXy9cbiAgfF98ICB8X3xffFxcX18sX3xcXF9fLF98X3xcXF9fX3wgXFxfL1xcXy8gXFxfXyxffF98ICBcXF9fX3xcbiAgQ3JlYXRlcyBtaWRkbGV3YXJlIGFycmF5IGZyb20gZ3JhcGgtICBUaGUgZ3JhcGggdHJhdmVyc2FsIEByZXR1cm4ge0FycmF5IG9mIE9iamVjdHN9IHdoZXJlIGVhY2ggb2JqZWN0IGNvbnRhaW5zIGluc3RydWN0aW9uIHNldHRpbmdzIHRvIGJlIHVzZWQgdGhyb3VnaCBhbiBpbXBsZW1lbnRpbmcgbW9kdWxlIHRvIGFkZCB0byBhIGNoYWluIG9mIG1pZGRsZXdhcmVzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuKi9cblxuLypcbiBcbiAgIF9fX19fICAgICAgICAgICAgICAgICAgICBfICAgICAgIF8gICAgICAgXG4gIHxfICAgX3xfXyBfIF9fIF9fXyAgXyBfXyB8IHwgX18gX3wgfF8gX19fIFxuICAgIHwgfC8gXyBcXCAnXyBgIF8gXFx8ICdfIFxcfCB8LyBfYCB8IF9fLyBfIFxcXG4gICAgfCB8ICBfXy8gfCB8IHwgfCB8IHxfKSB8IHwgKF98IHwgfHwgIF9fL1xuICAgIHxffFxcX19ffF98IHxffCB8X3wgLl9fL3xffFxcX18sX3xcXF9fXFxfX198XG4gICAgICAgICAgICAgICAgICAgICB8X3wgICAgICAgICAgICAgICAgICAgIFxuIFxuKi9cblxuLy8gbGV0IHVuZGVyc2NvcmUgPSByZXF1aXJlKCd1bmRlcnNjb3JlJylcbi8qKlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIG9mIHJlbmRlcmVkIEhUTUwgZG9jdW1lbnQgY29udGVudC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZU5lc3RlZFVuaXQoeyBuZXN0ZWRVbml0S2V5LCBhZGRpdGlvbmFsQ2hpbGROZXN0ZWRVbml0ID0gW10sIHBhdGhQb2ludGVyS2V5ID0gbnVsbCB9KSB7XG4gIC8vIHZpZXdzIGFyZ3VtZW50IHRoYXQgd2lsbCBiZSBpbml0aWFsbGl6ZWQgaW5zaWRlIHRlbXBsYXRlczpcbiAgLy8gbG9vcCB0aHJvdWdoIHRlbXBsYXRlIGFuZCBjcmVhdGUgcmVuZGVyZWQgdmlldyBjb250ZW50LlxuICBsZXQgdmlldyA9IGF3YWl0IG5lc3RlZFVuaXRJbnN0YW5jZS5sb29wSW5zZXJ0aW9uUG9pbnQoeyB0eXBlOiAnYWdncmVnYXRlSW50b1RlbXBsYXRlT2JqZWN0JyB9KVxuXG4gIGFzc2VydCh0aGlzLnBvcnRBcHBJbnN0YW5jZS5jb25maWcuY2xpZW50U2lkZVBhdGgsIFwi4oCiIGNsaWVudFNpZGVQYXRoIGNhbm5vdCBiZSB1bmRlZmluZWQuIGkuZS4gcHJldmlvdXMgbWlkZGxld2FyZXMgc2hvdWxkJ3ZlIHNldCBpdFwiKVxuICBsZXQgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKHRoaXMucG9ydEFwcEluc3RhbmNlLmNvbmZpZy5jbGllbnRTaWRlUGF0aCwgdW5pdEluc3RhbmNlLmZpbGUuZmlsZVBhdGgpXG4gIGxldCByZW5kZXJlZENvbnRlbnRcbiAgc3dpdGNoICh1bml0SW5zdGFuY2UucHJvY2Vzc0RhdGFJbXBsZW1lbnRhdGlvbikge1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSAndW5kZXJzY29yZVJlbmRlcmluZyc6XG4gICAgICByZW5kZXJlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnVuZGVyc2NvcmVSZW5kZXJpbmcoeyB0ZW1wbGF0ZVBhdGgsIHZpZXcgfSlcbiAgICAgIGJyZWFrXG4gIH1cblxuICBzd2l0Y2ggKHVuaXRJbnN0YW5jZS5wcm9jZXNzUmVuZGVyZWRDb250ZW50KSB7XG4gICAgY2FzZSAnd3JhcEpzVGFnJzpcbiAgICAgIHJlbmRlcmVkQ29udGVudCA9IGA8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIiBhc3luYz4ke3JlbmRlcmVkQ29udGVudH08L3NjcmlwdD5gXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6IC8vIHNraXBcbiAgfVxuXG4gIHJldHVybiByZW5kZXJlZENvbnRlbnRcbn1cblxuYXN5bmMgZnVuY3Rpb24gdW5kZXJzY29yZVJlbmRlcmluZyh7IHRlbXBsYXRlUGF0aCwgdmlldyB9KSB7XG4gIC8vIExvYWQgdGVtcGxhdGUgZmlsZS5cbiAgbGV0IHRlbXBsYXRlU3RyaW5nID0gYXdhaXQgZmlsZXN5c3RlbS5yZWFkRmlsZVN5bmModGVtcGxhdGVQYXRoLCAndXRmLTgnKVxuICAvLyBTaGFyZWQgYXJndW1lbnRzIGJldHdlZW4gYWxsIHRlbXBsYXRlcyBiZWluZyByZW5kZXJlZFxuICBjb25zdCB0ZW1wbGF0ZUFyZ3VtZW50ID0ge1xuICAgIHRlbXBsYXRlQ29udHJvbGxlcjogdGhpcyxcbiAgICBjb250ZXh0OiB0aGlzLnBvcnRBcHBJbnN0YW5jZS5jb250ZXh0LFxuICAgIEFwcGxpY2F0aW9uLFxuICAgIGFyZ3VtZW50OiB7fSxcbiAgfVxuICBsZXQgcmVuZGVyZWRDb250ZW50ID0gdW5kZXJzY29yZS50ZW1wbGF0ZSh0ZW1wbGF0ZVN0cmluZykoXG4gICAgT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgdGVtcGxhdGVBcmd1bWVudCwgLy8gdXNlIHRlbXBsYXRlQXJndW1lbnQgaW4gY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgeyB2aWV3LCB0ZW1wbGF0ZUFyZ3VtZW50IH0sIC8vIHBhc3MgdGVtcGxhdGVBcmd1bWVudCB0byBuZXN0ZWQgdGVtcGxhdGVzXG4gICAgKSxcbiAgKVxuICByZXR1cm4gcmVuZGVyZWRDb250ZW50XG59XG5cbmZ1bmN0aW9uIHJlbmRlcmVkQ29udGVudFN0cmluZyh2aWV3TmFtZSwgdmlld09iamVjdCkge1xuICAvLyBsb29wIHRocm91Z2h0IHRoZSBzdHJpbmdzIGFycmF5IHRvIGNvbWJpbmUgdGhlbSBhbmQgcHJpbnQgc3RyaW5nIGNvZGUgdG8gdGhlIGZpbGUuXG4gIGlmICh2aWV3T2JqZWN0W3ZpZXdOYW1lXSAmJiBBcnJheS5pc0FycmF5KHZpZXdPYmplY3Rbdmlld05hbWVdKSkge1xuICAgIHJldHVybiB2aWV3T2JqZWN0W3ZpZXdOYW1lXS5qb2luKCcnKSAvLyBqb2lucyBhbGwgYXJyYXkgY29tcG9uZW50cyBpbnRvIG9uZSBzdHJpbmcuXG4gIH1cbn1cblxubGV0IHRyYXZlcnNlUG9ydCA9IGFzeW5jIGZ1bmN0aW9uIGFnZ3JlZ2F0ZUludG9UZW1wbGF0ZU9iamVjdCgpIHtcbiAgbGV0IHZpZXcgPSB7fVxuICBpZiAodGhpcy5pbnNlcnRpb25Qb2ludCkge1xuICAgIGZvciAobGV0IGluc2VydGlvblBvaW50IG9mIHRoaXMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIGxldCBjaGlsZHJlbiA9IGF3YWl0IHRoaXMuZmlsdGVyQW5kT3JkZXJDaGlsZHJlbih7IGluc2VydGlvblBvaW50S2V5OiBpbnNlcnRpb25Qb2ludC5rZXkgfSlcbiAgICAgIGxldCBzdWJzZXF1ZW50ID0gYXdhaXQgdGhpcy5pbml0aWFsaXplSW5zZXJ0aW9uUG9pbnQoeyBpbnNlcnRpb25Qb2ludCwgY2hpbGRyZW4gfSlcbiAgICAgIGlmICghKGluc2VydGlvblBvaW50Lm5hbWUgaW4gdmlldykpIHZpZXdbaW5zZXJ0aW9uUG9pbnQubmFtZV0gPSBbXVxuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodmlld1tpbnNlcnRpb25Qb2ludC5uYW1lXSwgc3Vic2VxdWVudClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZpZXdcbn1cblxuLypcbiBcbiAgICAgICAgICAgIF8gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgX19fICBfX198IHxfXyAgIF9fXyBfIF9fIF9fXyAgIF9fIF8gXG4gIC8gX198LyBfX3wgJ18gXFwgLyBfIFxcICdfIGAgXyBcXCAvIF9gIHxcbiAgXFxfXyBcXCAoX198IHwgfCB8ICBfXy8gfCB8IHwgfCB8IChffCB8XG4gIHxfX18vXFxfX198X3wgfF98XFxfX198X3wgfF98IHxffFxcX18sX3xcbiBBUEkgU2NoZW1hXG4gIChXaGlsZSB0aGUgZGF0YWJhc2UgbW9kZWxzIGFyZSBzZXBhcmF0ZSBpbiB0aGVpciBvd24gZnVuY3Rpb25zIG9yIGNvdWxkIGJlIGV4cG9zZWQgdGhyb3VnaCBhIGNsYXNzIG1vZHVsZSlcblxuICAtIFJlc29sdmVyIGZ1bmN0aW9uID0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZGF0YS5cbiAgLSBEYXRhIGxvYWRlciA9IG1vZHVsZSB0aGF0IGFnZ3JlZ2F0ZXMgZHVwbGljYXRlIGNhbGxzLiBTb2x2aW5nIHRoZSBuKzEgcHJvYmxlbSwgd2hlcmUgZWFjaCBxdWVyeSBoYXMgYSBzdWJzZXF1ZW50IHF1ZXJ5LCBsaW5lYXIgZ3JhcGguIFRvIG5vZGVqcyBpdCB1c2VzIG5leHRUaWNrIGZ1bmN0aW9uIHRvIGFuYWx5c2UgdGhlIHByb21pc2VzIGJlZm9yZSB0aGVpciBleGVjdXRpb24gYW5kIHByZXZlbnQgbXVsdGlwbGUgcm91bmQgdHJpcHMgdG8gdGhlIHNlcnZlciBmb3IgdGhlIHNhbWUgZGF0YS5cbiAgLSBNYXBwaW5nIC0gdGhyb3VnaCByb3NvbHZlciBmdW5jdGlvbnMuXG4gIC0gU2NoZW1hID0gaXMgdGhlIHN0cnVjdHVyZSAmIHJlbGF0aW9uc2hpcHMgb2YgdGhlIGFwaSBkYXRhLiBpLmUuIGRlZmluZXMgaG93IGEgY2xpZW50IGNhbiBmZXRjaCBhbmQgdXBkYXRlIGRhdGEuXG4gICAgICBlYWNoIHNjaGVtYSBoYXMgYXBpIGVudHJ5cG9pbnRzLiBFYWNoIGZpZWxkIGNvcnJlc3BvbmRzIHRvIGEgcmVzb2x2ZXIgZnVuY3Rpb24uXG4gIERhdGEgZmV0Y2hpbmcgY29tcGxleGl0eSBhbmQgZGF0YSBzdHJ1Y3R1cmluZyBpcyBoYW5kbGVkIGJ5IHNlcnZlciBzaWRlIHJhdGhlciB0aGFuIGNsaWVudC5cblxuICAzIHR5cGVzIG9mIHBvc3NpYmxlIGFwaSBhY3Rpb25zOiBcbiAgLSBRdWVyeVxuICAtIE11dGF0aW9uXG4gIC0gU3Vic2NyaXB0aW9uIC0gY3JlYXRlcyBhIHN0ZWFkeSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlci5cblxuICBGZXRjaGluZyBhcHByb2FjaGVzOiBcbiAg4oCiIEltcGVyYXRpdmUgZmV0Y2hpbmc6IFxuICAgICAgLSBjb25zdHJ1Y3RzICYgc2VuZHMgSFRUUCByZXF1ZXN0LCBlLmcuIHVzaW5nIGpzIGZldGNoLlxuICAgICAgLSByZWNlaXZlICYgcGFyc2Ugc2VydmVyIHJlc3BvbnNlLlxuICAgICAgLSBzdG9yZSBkYXRhIGxvY2FsbHksIGUuZy4gaW4gbWVtb3J5IG9yIHBlcnNpc3RlbnQuIFxuICAgICAgLSBkaXNwbGF5IFVJLlxuICDigKIgRGVjbGFyYXRpdmUgZmV0Y2hpbmcgZS5nLiB1c2luZyBHcmFwaFFMIGNsaWVudHM6IFxuICAgICAgLSBEZXNjcmliZSBkYXRhIHJlcXVpcmVtZW50cy5cbiAgICAgIC0gRGlzcGxheSBpbmZvcm1hdGlvbiBpbiB0aGUgVUkuXG5cbiAgUmVxdWVzdDogXG4gIHtcbiAgICAgIGFjdGlvbjogcXVlcnksXG4gICAgICBlbnRyeXBvaW50OiB7XG4gICAgICAgICAga2V5OiBcIkFydGljbGVcIlxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgbmFtZTogXCJzaW5nbGVcIixcbiAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICAgIGtleTogXCJhcnRpY2xlMVwiXG4gICAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZpZWxkOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBrZXluYW1lOiBcInRpdGxlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAga2V5bmFtZTogXCJwYXJhZ3JhcGhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBrZXluYW1lOiBcImF1dGhvcnNcIlxuICAgICAgICAgIH0sXG4gICAgICBdXG4gIH1cblxuICBSZXNwb25zZSA6XG4gIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0aXRsZTogXCIuLi5cIixcbiAgICAgICAgICBwYXJhZ3JhcGg6ICcuLi4nLFxuICAgICAgICAgIGF1dGhvcjoge1xuICAgICAgICAgICAgICBuYW1lOiAnLi4uJyxcbiAgICAgICAgICAgICAgYWdlOiAyMFxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG5cbiAgTmVzdGVkIFVuaXQgZXhlY3V0aW9uIHN0ZXBzOiAgXG7igKIgXG4qL1xuXG5sZXQgc2NoZW1hID0gKCkgPT4ge1xuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gdHlwZSBhZ2dyZWdhdGVJbnRvQ29udGVudEFycmF5XG4gICAqL1xuICAvKiBleG1wbGUgcmVxdWVzdCBib2R5OiBcbntcbiAgICBcImZpZWxkTmFtZVwiOiBcImFydGljbGVcIixcbiAgICBcImZpZWxkXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJmaWVsZE5hbWVcIjogXCJ0aXRsZVwiLFxuICAgICAgICAgICAgXCJmaWVsZFwiOiBbXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImZpZWxkTmFtZVwiOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgICAgXCJmaWVsZFwiOiBbXVxuICAgICAgICB9XG4gICAgXSxcbiAgICBcInNjaGVtYU1vZGVcIjogXCJub25TdHJpY3RcIiwgLy8gYWxsb3cgZW1wdHkgZGF0YXNldHMgZm9yIHNwZWNpZmllZCBmaWVsZHMgaW4gdGhlIG5lc3RlZCB1bml0IHNjaGVtYS5cbiAgICBcImV4dHJhZmllbGRcIjogdHJ1ZSAvLyBpbmNsdWRlcyBmaWVsZHMgdGhhdCBhcmUgbm90IGV4dHJhY3RlZCB1c2luZyB0aGUgc2NoZW1hLlxufSAqL1xuICBjb25zdCB7IGFkZCwgZXhlY3V0ZSwgY29uZGl0aW9uYWwsIGV4ZWN1dGlvbkxldmVsIH0gPSByZXF1aXJlKCdAZGVwZW5kZW5jeS9jb21tb25QYXR0ZXJuL3NvdXJjZS9kZWNvcmF0b3JVdGlsaXR5LmpzJylcbiAgZnVuY3Rpb24gc2NoZW1hKHsgdGhpc0FyZyB9KSB7XG4gICAgLy8gZnVuY3Rpb24gd3JhcHBlciB0byBzZXQgdGhpc0FyZyBvbiBpbXBsZW1lbnRhaW9uIG9iamVjdCBmdW5jdGlvbnMuXG5cbiAgICBsZXQgc2VsZiA9IHtcbiAgICAgIEBleGVjdXRpb25MZXZlbCgpXG4gICAgICBhc3luYyBpbml0aWFsaXplTmVzdGVkVW5pdCh7IG5lc3RlZFVuaXRLZXksIGFkZGl0aW9uYWxDaGlsZE5lc3RlZFVuaXQgPSBbXSwgcGF0aFBvaW50ZXJLZXkgPSBudWxsLCBwYXJlbnQgPSB0aGlzLCBhcmd1bWVudCA9IHt9IH0pIHtcbiAgICAgICAgLy8gRW50cnlwb2ludCBJbnN0YW5jZVxuICAgICAgICAvLyBleHRyYWN0IHJlcXVlc3QgZGF0YSBhY3Rpb24gYXJndW1lbnRzLiBhcmd1bWVudHMgZm9yIGEgcXVlcnkvbXV0YXRpb24vc3Vic2NyaXB0aW9uLlxuICAgICAgICBpZiAodGhpcy5leGVjdXRpb25MZXZlbCA9PSAndG9wTGV2ZWwnKSB7XG4gICAgICAgICAgbmVzdGVkVW5pdEluc3RhbmNlLnJlcXVlc3RPcHRpb24gPSB0aGlzLnBvcnRBcHBJbnN0YW5jZS5jb250ZXh0LnJlcXVlc3QuYm9keVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNoaWxkL25lc3RlZFxuICAgICAgICAgIGxldCBmaWVsZEFycmF5ID0gcGFyZW50LnJlcXVlc3RPcHRpb24uZmllbGQgLy8gb2JqZWN0IGFycmF5XG4gICAgICAgICAgaWYgKChmaWVsZEFycmF5ICYmIGZpZWxkQXJyYXkubGVuZ3RoID09IDApIHx8ICFmaWVsZEFycmF5KSB7XG4gICAgICAgICAgICBuZXN0ZWRVbml0SW5zdGFuY2UucmVxdWVzdE9wdGlvbiA9IHt9IC8vIGNvbnRpbnVlIHRvIHJlc29sdmUgZGF0YXNldCBhbmQgYWxsIHN1YnNlcXVlbnQgTmVzdGVkdW5pdHMgb2YgbmVzdGVkIGRhdGFzZXQgaW4gY2FzZSBhcmUgb2JqZWN0cy5cbiAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkQXJyYXkpIHtcbiAgICAgICAgICAgIG5lc3RlZFVuaXRJbnN0YW5jZS5yZXF1ZXN0T3B0aW9uID0gZmllbGRBcnJheS5maW5kKGZpZWxkID0+IGZpZWxkLmZpZWxkTmFtZSA9PSB1bml0SW5zdGFuY2UuZmllbGROYW1lKSAvLyB3aGVyZSBmaWVsZE5hbWVzIG1hdGNoXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgZmllbGRuYW1lIGV4aXN0cyBpbiB0aGUgcmVxdWVzdCBvcHRpb24sIGlmIG5vdCBza2lwIG5lc3RlZCB1bml0LlxuICAgICAgICBpZiAoIW5lc3RlZFVuaXRJbnN0YW5jZS5yZXF1ZXN0T3B0aW9uKSByZXR1cm4gLy8gZmllbGROYW1lIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBwYXJlbnQgbmVzdGVkVW5pdCwgdGhlcmVmb3JlIHNraXAgaXRzIGV4ZWN1dGlvblxuICAgICAgICBuZXN0ZWRVbml0SW5zdGFuY2UuZGF0YXNldCA9IGF3YWl0IHVuaXRJbnN0YW5jZS5yZXNvbHZlRGF0YXNldCh7IHBhcmVudFJlc3VsdDogYXJndW1lbnQuZGF0YXNldCB8fCBwYXJlbnQuZGF0YXNldCB9KVxuICAgICAgICAvLyBUT0RPOiBGaXggcmVxdWVzdE9wdGlvbiAtIGkuZS4gYWJvdmUgaXQgaXMgdXNlZCB0byBwYXNzIFwiZmllbGRcIiBvcHRpb24gb25seS5cbiAgICAgICAgaWYgKHRoaXMucG9ydEFwcEluc3RhbmNlLmNvbnRleHQucmVxdWVzdC5ib2R5LnNjaGVtYU1vZGUgPT0gJ25vblN0cmljdCcpIHtcbiAgICAgICAgICAvLyBEb24ndCBlbmZvcmNlIHN0cmljdCBzY2hlbWEsIGkuZS4gYWxsIG5lc3RlZCBjaGlsZHJlbiBzaG91bGQgZXhpc3QuXG4gICAgICAgICAgLy8gaWYobmVzdGVkVW5pdEluc3RhbmNlLmRhdGFzZXQpIG5lc3RlZFVuaXRJbnN0YW5jZS5kYXRhc2V0ID0gbnVsbCAvLyBUT0RPOiB0aHJvd3MgZXJyb3IgYXMgbmV4dCBpdCBpcyBiZWluZyB1c2VkLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydC5ub3RFcXVhbChuZXN0ZWRVbml0SW5zdGFuY2UuZGF0YXNldCwgdW5kZWZpbmVkLCBg4oCiIHJldHVybmVkIGRhdGFzZXQgY2Fubm90IGJlIHVuZGVmaW5lZCBmb3IgZmllbGROYW1lOiAke3VuaXRJbnN0YW5jZS5maWVsZE5hbWV9LmApXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayB0eXBlIG9mIGRhdGFzZXRcbiAgICAgICAgbGV0IGRhdGFzZXRIYW5kbGluZ1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXN0ZWRVbml0SW5zdGFuY2UuZGF0YXNldCkgJiYgbmVzdGVkVW5pdEluc3RhbmNlLmNoaWxkcmVuICYmIG5lc3RlZFVuaXRJbnN0YW5jZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICBkYXRhc2V0SGFuZGxpbmcgPSAnc2VxdWVuY2UnXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5lc3RlZFVuaXRJbnN0YW5jZS5kYXRhc2V0ID09ICdvYmplY3QnICYmIG5lc3RlZFVuaXRJbnN0YW5jZS5jaGlsZHJlbiAmJiBuZXN0ZWRVbml0SW5zdGFuY2UuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIG9iamVjdFxuICAgICAgICAgIGRhdGFzZXRIYW5kbGluZyA9ICduZXN0ZWQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm9uLW5lc3RlZCB2YWx1ZVxuICAgICAgICAgIGRhdGFzZXRIYW5kbGluZyA9ICdub25OZXN0ZWQnXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgYXJyYXksIG9iamVjdCwgb3Igbm9uLW5lc3RlZCB2YWx1ZVxuICAgICAgICBsZXQgb2JqZWN0ID0ge30gLy8gZm9ybWF0dGVkIG9iamVjdCB3aXRoIHJlcXVlc3RlZCBmaWVsZHNcbiAgICAgICAgc3dpdGNoIChkYXRhc2V0SGFuZGxpbmcpIHtcbiAgICAgICAgICBjYXNlICdzZXF1ZW5jZSc6XG4gICAgICAgICAgICBsZXQgcHJvbWlzZUFycmF5ID0gbmVzdGVkVW5pdEluc3RhbmNlLmRhdGFzZXQubWFwKGRvY3VtZW50ID0+IHtcbiAgICAgICAgICAgICAgbGV0IGFyZ3VtZW50ID0ge31cbiAgICAgICAgICAgICAgYXJndW1lbnRbJ2RhdGFzZXQnXSA9IGRvY3VtZW50XG4gICAgICAgICAgICAgIHJldHVybiBuZXN0ZWRVbml0SW5zdGFuY2UubG9vcEluc2VydGlvblBvaW50KHsgdHlwZTogJ2FnZ3JlZ2F0ZUludG9Db250ZW50QXJyYXknLCBhcmd1bWVudCB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGxldCBzdWJzZXF1ZW50RGF0YXNldEFycmF5ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZUFycmF5KVxuICAgICAgICAgICAgb2JqZWN0W3VuaXRJbnN0YW5jZS5maWVsZE5hbWVdID0gc3Vic2VxdWVudERhdGFzZXRBcnJheS5tYXAoKHN1YnNlcXVlbnREYXRhc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXREYXRhc2V0T2ZOZXN0ZWRUeXBlKHtcbiAgICAgICAgICAgICAgICBzdWJzZXF1ZW50RGF0YXNldCxcbiAgICAgICAgICAgICAgICBkYXRhc2V0OiBuZXN0ZWRVbml0SW5zdGFuY2UuZGF0YXNldFtpbmRleF0sXG4gICAgICAgICAgICAgICAgb3B0aW9uOiB7XG4gICAgICAgICAgICAgICAgICBleHRyYWZpZWxkOiBuZXN0ZWRVbml0SW5zdGFuY2UucmVxdWVzdE9wdGlvbi5leHRyYWZpZWxkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ25lc3RlZCc6IC8vIGlmIGZpZWxkIHRyZWF0ZWQgYXMgYW4gb2JqZWN0IHdpdGggbmVzdGVkIGZpZWxkc1xuICAgICAgICAgICAgbGV0IHN1YnNlcXVlbnREYXRhc2V0ID0gYXdhaXQgbmVzdGVkVW5pdEluc3RhbmNlLmxvb3BJbnNlcnRpb25Qb2ludCh7IHR5cGU6ICdhZ2dyZWdhdGVJbnRvQ29udGVudEFycmF5JyB9KVxuICAgICAgICAgICAgb2JqZWN0W3VuaXRJbnN0YW5jZS5maWVsZE5hbWVdID0gdGhpcy5mb3JtYXREYXRhc2V0T2ZOZXN0ZWRUeXBlKHtcbiAgICAgICAgICAgICAgc3Vic2VxdWVudERhdGFzZXQsXG4gICAgICAgICAgICAgIGRhdGFzZXQ6IG5lc3RlZFVuaXRJbnN0YW5jZS5kYXRhc2V0LFxuICAgICAgICAgICAgICBvcHRpb246IHtcbiAgICAgICAgICAgICAgICBleHRyYWZpZWxkOiBuZXN0ZWRVbml0SW5zdGFuY2UucmVxdWVzdE9wdGlvbi5leHRyYWZpZWxkLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhc2UgJ25vbk5lc3RlZCc6XG4gICAgICAgICAgICAvLyBsb29waW5nIG92ZXIgbmVzdGVkIHVuaXRzIGNhbiBtYW5pcHVsYXRlIHRoZSBkYXRhIGluIGEgZGlmZmVyZW50IHdheSB0aGFuIHJlZ3VsYXIgYWdncmVnYXRpb24gaW50byBhbiBhcnJheS5cbiAgICAgICAgICAgIG9iamVjdFt1bml0SW5zdGFuY2UuZmllbGROYW1lXSA9IG5lc3RlZFVuaXRJbnN0YW5jZS5kYXRhc2V0XG5cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWFsIHdpdGggcmVxdWVzdGVkIGFsbCBmaWVsZHMgd2l0aG91dCB0aGUgZmllbGQgb3B0aW9uIHdoZXJlIGV4ZWN1dGlvbiBvZiBzdWJuZXN0ZWR1bml0cyBpcyByZXF1aXJlZCB0byBtYW5pcHVsYXRlIHRoZSBkYXRhLlxuXG4gICAgICAgIHJldHVybiBvYmplY3RcbiAgICAgIH0sXG5cbiAgICAgIGZvcm1hdERhdGFzZXRPZk5lc3RlZFR5cGUoeyBzdWJzZXF1ZW50RGF0YXNldCwgZGF0YXNldCwgb3B0aW9uIH0pIHtcbiAgICAgICAgbGV0IG9iamVjdCA9IHt9XG4gICAgICAgIHN1YnNlcXVlbnREYXRhc2V0LmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgIG9iamVjdCA9IE9iamVjdC5hc3NpZ24ob2JqZWN0LCBmaWVsZClcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKG9wdGlvbi5leHRyYWZpZWxkKSB7XG4gICAgICAgICAgLy8gZXh0cmFmaWVsZCBvcHRpb25cbiAgICAgICAgICBvYmplY3QgPSBPYmplY3QuYXNzaWduKGRhdGFzZXQsIG9iamVjdCkgLy8gb3ZlcnJpZGUgc3Vic2VxdWVudCBmaWVsZHMgYW5kIGtlZXAgdW50cmFja2VkIGZpZWxkcy5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0XG4gICAgICB9LFxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNlbGYpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBzZWxmW2tleV0gPSBzZWxmW2tleV0uYmluZCh0aGlzQXJnKVxuICAgIH0sIHt9KVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiByZXNvbHZlRGF0YXNldCh7XG4gICAgcGFyZW50UmVzdWx0ID0gbnVsbCxcbiAgICAvLyB0aGlzLmFyZ3MgLSBuZXN0ZWRVbml0IGFyZ3MgZmllbGQuXG4gIH0pIHtcbiAgICAvLyBbMl0gcmVxdWlyZSAmIGNoZWNrIGNvbmRpdGlvblxuICAgIGxldCBkYXRhc2V0XG4gICAgY29uc3QgYWxnb3JpdGhtID0gdGhpcy5maWxlLmFsZ29yaXRobSAvLyByZXNvbHZlciBmb3IgZGF0YXNldFxuICAgIHN3aXRjaCAoXG4gICAgICBhbGdvcml0aG0udHlwZSAvLyBpbiBvcmRlciB0byBjaG9vc2UgaG93IHRvIGhhbmRsZSB0aGUgYWxnb3JpdGhtIChhcyBhIG1vZHVsZSA/IGEgZmlsZSB0byBiZSBpbXBvcnRlZCA/Li4uKVxuICAgICkge1xuICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IG1vZHVsZSA9IHJlcXVpcmUoYWxnb3JpdGhtLnBhdGgpLmRlZmF1bHRcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ2Z1bmN0aW9uJykgbW9kdWxlID0gbW9kdWxlLmRlZmF1bHQgLy8gY2FzZSBlczYgbW9kdWxlIGxvYWRlZCB3aXRoIHJlcXVpcmUgZnVuY3Rpb24gKHdpbGwgbG9hZCBpdCBhcyBhbiBvYmplY3QpXG4gICAgICAgICAgbGV0IHJlc29sdmVyID0gbW9kdWxlKCkgLyppbml0aWFsIGV4ZWN1dGUgZm9yIHNldHRpbmcgcGFyYW1ldGVyIGNvbnRleHQuKi9cbiAgICAgICAgICBsZXQgcmVzb2x2ZXJBcmd1bWVudCA9IE9iamVjdC5hc3NpZ24oLi4uW3RoaXMuYXJncywgYWxnb3JpdGhtLmFyZ3VtZW50XS5maWx0ZXIoQm9vbGVhbikpIC8vIHJlbW92ZSB1bmRlZmluZWQvbnVsbC9mYWxzZSBvYmplY3RzIGJlZm9yZSBtZXJnaW5nLlxuICAgICAgICAgIGRhdGFzZXQgPSBhd2FpdCByZXNvbHZlcih7XG4gICAgICAgICAgICBwb3J0Q2xhc3NJbnN0YW5jZTogdGhpcy5wb3J0QXBwSW5zdGFuY2UsIC8vIGNvbnRhaW5zIGFsc28gcG9ydENsYXNzSW5zdGFuY2UuY29udGV4dCBvZiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgIGFyZ3M6IHJlc29sdmVyQXJndW1lbnQsXG4gICAgICAgICAgICBwYXJlbnRSZXN1bHQsIC8vIHBhcmVudCBkYXRhc2V0IHJlc3VsdC5cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzZXRcbiAgfVxufVxuIl19