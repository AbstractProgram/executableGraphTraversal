"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.entityPrototype = exports.Prototype = exports.Reference = exports.Connection = void 0;var _assert = _interopRequireDefault(require("assert"));
var _entity = require("@dependency/entity");
var _GraphElementClass = require("./GraphElement.class.js");




const { class: Connection, reference: Reference, constructablePrototype: Prototype, entityPrototype } = new _GraphElementClass.GraphElement.clientInterface({ description: 'Connection' });exports.entityPrototype = entityPrototype;exports.Prototype = Prototype;exports.Reference = Reference;exports.Connection = Connection;









Object.assign(entityPrototype, {
  constructor: Symbol('Connection:key.constructor') });









Prototype[_entity.Constructable.reference.initialize.functionality].setter.call(Prototype, {});








Prototype[_entity.Constructable.reference.constructor.functionality].setter.call(Prototype, {
  [Reference.key.constructor]({
    data,
    concreteBehaviorList,
    callerClass = this })
  {
    let { key } = data;
    (0, _assert.default)(key, `â€¢ ${key} Key should be present. The passed value is either undefined, null, or empty string.`);
    let instance = _entity.Constructable[_entity.Constructable.reference.constructor.functionality].switch.call(callerClass, { implementationKey: _entity.Entity.reference.key.concereteBehavior })({ concreteBehaviorList, data });
    instance.key = key;
    return instance;
  } });









Connection.clientInterface = Prototype[_entity.Constructable.reference.clientInterface.functionality].switch.call(Connection, {
  implementationKey: _entity.Entity.reference.key.instanceDelegatingToEntityInstancePrototype })(
{
  constructorImplementation: _entity.Entity.reference.key.concereteBehavior });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NvdXJjZS9jb25zdHJ1Y3RhYmxlL0Nvbm5lY3Rpb24uY2xhc3MuanMiXSwibmFtZXMiOlsiY2xhc3MiLCJDb25uZWN0aW9uIiwicmVmZXJlbmNlIiwiUmVmZXJlbmNlIiwiY29uc3RydWN0YWJsZVByb3RvdHlwZSIsIlByb3RvdHlwZSIsImVudGl0eVByb3RvdHlwZSIsIkdyYXBoRWxlbWVudCIsImNsaWVudEludGVyZmFjZSIsImRlc2NyaXB0aW9uIiwiT2JqZWN0IiwiYXNzaWduIiwiY29uc3RydWN0b3IiLCJTeW1ib2wiLCJDb25zdHJ1Y3RhYmxlIiwiaW5pdGlhbGl6ZSIsImZ1bmN0aW9uYWxpdHkiLCJzZXR0ZXIiLCJrZXkiLCJkYXRhIiwiY29uY3JldGVCZWhhdmlvckxpc3QiLCJjYWxsZXJDbGFzcyIsImluc3RhbmNlIiwic3dpdGNoIiwiaW1wbGVtZW50YXRpb25LZXkiLCJFbnRpdHkiLCJjb25jZXJldGVCZWhhdmlvciIsImluc3RhbmNlRGVsZWdhdGluZ1RvRW50aXR5SW5zdGFuY2VQcm90b3R5cGUiLCJjb25zdHJ1Y3RvckltcGxlbWVudGF0aW9uIl0sIm1hcHBpbmdzIjoiOFBBQUE7QUFDQTtBQUNBOzs7OztBQUtPLE1BQU0sRUFBRUEsS0FBSyxFQUFFQyxVQUFULEVBQXFCQyxTQUFTLEVBQUVDLFNBQWhDLEVBQTJDQyxzQkFBc0IsRUFBRUMsU0FBbkUsRUFBOEVDLGVBQTlFLEtBQWtHLElBQUlDLGdDQUFhQyxlQUFqQixDQUFpQyxFQUFFQyxXQUFXLEVBQUUsWUFBZixFQUFqQyxDQUF4RyxDOzs7Ozs7Ozs7O0FBVVBDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjTCxlQUFkLEVBQStCO0FBQzdCTSxFQUFBQSxXQUFXLEVBQUVDLE1BQU0sQ0FBQyw0QkFBRCxDQURVLEVBQS9COzs7Ozs7Ozs7O0FBV1dSLFNBQVMsQ0FBQ1Msc0JBQWNaLFNBQWQsQ0FBd0JhLFVBQXhCLENBQW1DQyxhQUFwQyxDQUFULENBQTREQyxNQUF2RSxNQUFBWixTQUFTLEVBQXFFLEVBQXJFLENBQVQ7Ozs7Ozs7OztBQVNXQSxTQUFTLENBQUNTLHNCQUFjWixTQUFkLENBQXdCVSxXQUF4QixDQUFvQ0ksYUFBckMsQ0FBVCxDQUE2REMsTUFBeEUsTUFBQVosU0FBUyxFQUFzRTtBQUM3RSxHQUFDRixTQUFTLENBQUNlLEdBQVYsQ0FBY04sV0FBZixFQUE0QjtBQUMxQk8sSUFBQUEsSUFEMEI7QUFFMUJDLElBQUFBLG9CQUYwQjtBQUcxQkMsSUFBQUEsV0FBVyxHQUFHLElBSFksRUFBNUI7QUFJRztBQUNELFFBQUksRUFBRUgsR0FBRixLQUFVQyxJQUFkO0FBQ0EseUJBQU9ELEdBQVAsRUFBYSxLQUFJQSxHQUFJLHNGQUFyQjtBQUNBLFFBQUlJLFFBQVEsR0FBZ0JSLHNCQUFjQSxzQkFBY1osU0FBZCxDQUF3QlUsV0FBeEIsQ0FBb0NJLGFBQWxELEVBQWlFTyxNQUE5RSxNQUFBRixXQUFXLEVBQTBFLEVBQUVHLGlCQUFpQixFQUFFQyxlQUFPdkIsU0FBUCxDQUFpQmdCLEdBQWpCLENBQXFCUSxpQkFBMUMsRUFBMUUsQ0FBWCxDQUFvSixFQUFFTixvQkFBRixFQUF3QkQsSUFBeEIsRUFBcEosQ0FBZjtBQUNBRyxJQUFBQSxRQUFRLENBQUNKLEdBQVQsR0FBZUEsR0FBZjtBQUNBLFdBQU9JLFFBQVA7QUFDRCxHQVg0RSxFQUF0RSxDQUFUOzs7Ozs7Ozs7O0FBcUJBckIsVUFBVSxDQUFDTyxlQUFYLEdBQXlDSCxTQUFTLENBQUNTLHNCQUFjWixTQUFkLENBQXdCTSxlQUF4QixDQUF3Q1EsYUFBekMsQ0FBVCxDQUFpRU8sTUFBN0UsTUFBQXRCLFVBQVUsRUFBMEU7QUFDL0d1QixFQUFBQSxpQkFBaUIsRUFBRUMsZUFBT3ZCLFNBQVAsQ0FBaUJnQixHQUFqQixDQUFxQlMsMkNBRHVFLEVBQTFFLENBQVY7QUFFMUI7QUFDREMsRUFBQUEseUJBQXlCLEVBQUVILGVBQU92QixTQUFQLENBQWlCZ0IsR0FBakIsQ0FBcUJRLGlCQUQvQyxFQUYwQixDQUE3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0J1xuaW1wb3J0IHsgRW50aXR5LCBDb25zdHJ1Y3RhYmxlLCBzeW1ib2wgfSBmcm9tICdAZGVwZW5kZW5jeS9lbnRpdHknXG5pbXBvcnQgeyBHcmFwaEVsZW1lbnQgfSBmcm9tICcuL0dyYXBoRWxlbWVudC5jbGFzcy5qcydcblxuLy8gTm90ZTogYGNvbm5lY3Rpb25JbnN0YW5jZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25gIHdpbGwgbm90IHdvcmsgYXMgRW50aXR5IG1vZHVsZSBjcmVhdGVzIE9iamVjdHMgcmF0aGVyIHRoYW4gY2FsbGFibGUgRnVuY3Rpb24gaW5zdGFuY2VzLiBDb3VsZCBjb25zaWRlciBjaGFuZ2luZyB0aGlzIGJlaGF2aW9yIHRvIGFsbG93IG5hdGl2ZSBjb25zdHJ1Y3RvciBjaGVja2luZyB0byB3b3JrLlxuLy8gYGlmICghKGNvbm5lY3Rpb25JbnN0YW5jZS5jb25zdHJ1Y3RvciA9PSBDb25uZWN0aW9uKSlgIHdvcmtzLlxuXG5leHBvcnQgY29uc3QgeyBjbGFzczogQ29ubmVjdGlvbiwgcmVmZXJlbmNlOiBSZWZlcmVuY2UsIGNvbnN0cnVjdGFibGVQcm90b3R5cGU6IFByb3RvdHlwZSwgZW50aXR5UHJvdG90eXBlIH0gPSBuZXcgR3JhcGhFbGVtZW50LmNsaWVudEludGVyZmFjZSh7IGRlc2NyaXB0aW9uOiAnQ29ubmVjdGlvbicgfSlcblxuLypcbiAgICAgICAgICAgICAgICAgICBfICAgICAgICBfICAgICAgICAgICAgICAgICAgICBfX19fICAgICAgIF8gICAgICAgICAgICAgICAgICBfICAgXyAgICAgICAgICAgICBcbiAgIF8gX18gIF8gX18gX19fIHwgfF8gX19fIHwgfF8gXyAgIF8gXyBfXyAgIF9fX3wgIF8gXFwgIF9fX3wgfCBfX18gIF9fIF8gIF9fIF98IHxfKF8pIF9fXyAgXyBfXyAgXG4gIHwgJ18gXFx8ICdfXy8gXyBcXHwgX18vIF8gXFx8IF9ffCB8IHwgfCAnXyBcXCAvIF8gXFwgfCB8IHwvIF8gXFwgfC8gXyBcXC8gX2AgfC8gX2AgfCBfX3wgfC8gXyBcXHwgJ18gXFwgXG4gIHwgfF8pIHwgfCB8IChfKSB8IHx8IChfKSB8IHxffCB8X3wgfCB8XykgfCAgX18vIHxffCB8ICBfXy8gfCAgX18vIChffCB8IChffCB8IHxffCB8IChfKSB8IHwgfCB8XG4gIHwgLl9fL3xffCAgXFxfX18vIFxcX19cXF9fXy8gXFxfX3xcXF9fLCB8IC5fXy8gXFxfX198X19fXy8gXFxfX198X3xcXF9fX3xcXF9fLCB8XFxfXyxffFxcX198X3xcXF9fXy98X3wgfF98XG4gIHxffCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX18vfF98ICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fXy8gICAgICAgICAgICAgICAgICAgICAgICAgXG4qL1xuT2JqZWN0LmFzc2lnbihlbnRpdHlQcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IFN5bWJvbCgnQ29ubmVjdGlvbjprZXkuY29uc3RydWN0b3InKSxcbn0pXG5cbi8qXG4gICBfICAgICAgIF8gXyAgIF8gICAgICAgXyBfICAgICAgICAgXG4gIChfKV8gX18gKF8pIHxfKF8pIF9fIF98IChfKV9fX19fX18gXG4gIHwgfCAnXyBcXHwgfCBfX3wgfC8gX2AgfCB8IHxfICAvIF8gXFxcbiAgfCB8IHwgfCB8IHwgfF98IHwgKF98IHwgfCB8LyAvICBfXy9cbiAgfF98X3wgfF98X3xcXF9ffF98XFxfXyxffF98Xy9fX19cXF9fX3xcbiovXG5Qcm90b3R5cGU6OlByb3RvdHlwZVtDb25zdHJ1Y3RhYmxlLnJlZmVyZW5jZS5pbml0aWFsaXplLmZ1bmN0aW9uYWxpdHldLnNldHRlcih7fSlcblxuLypcbiAgICAgICAgICAgICAgICAgICAgICAgXyAgICAgICAgICAgICAgICAgICBfICAgICAgICAgICAgIFxuICAgIF9fXyBfX18gIF8gX18gIF9fX3wgfF8gXyBfXyBfICAgXyAgX19ffCB8XyBfX18gIF8gX18gXG4gICAvIF9fLyBfIFxcfCAnXyBcXC8gX198IF9ffCAnX198IHwgfCB8LyBfX3wgX18vIF8gXFx8ICdfX3xcbiAgfCAoX3wgKF8pIHwgfCB8IFxcX18gXFwgfF98IHwgIHwgfF98IHwgKF9ffCB8fCAoXykgfCB8ICAgXG4gICBcXF9fX1xcX19fL3xffCB8X3xfX18vXFxfX3xffCAgIFxcX18sX3xcXF9fX3xcXF9fXFxfX18vfF98ICAgXG4qL1xuUHJvdG90eXBlOjpQcm90b3R5cGVbQ29uc3RydWN0YWJsZS5yZWZlcmVuY2UuY29uc3RydWN0b3IuZnVuY3Rpb25hbGl0eV0uc2V0dGVyKHtcbiAgW1JlZmVyZW5jZS5rZXkuY29uc3RydWN0b3JdKHtcbiAgICBkYXRhLCAvLyBkYXRhIHRvIGJlIG1lcmdlZCBpbnRvIHRoZSBpbnN0YW5jZVxuICAgIGNvbmNyZXRlQmVoYXZpb3JMaXN0LFxuICAgIGNhbGxlckNsYXNzID0gdGhpcyxcbiAgfSkge1xuICAgIGxldCB7IGtleSB9ID0gZGF0YVxuICAgIGFzc2VydChrZXksIGDigKIgJHtrZXl9IEtleSBzaG91bGQgYmUgcHJlc2VudC4gVGhlIHBhc3NlZCB2YWx1ZSBpcyBlaXRoZXIgdW5kZWZpbmVkLCBudWxsLCBvciBlbXB0eSBzdHJpbmcuYClcbiAgICBsZXQgaW5zdGFuY2UgPSBjYWxsZXJDbGFzczo6Q29uc3RydWN0YWJsZVtDb25zdHJ1Y3RhYmxlLnJlZmVyZW5jZS5jb25zdHJ1Y3Rvci5mdW5jdGlvbmFsaXR5XS5zd2l0Y2goeyBpbXBsZW1lbnRhdGlvbktleTogRW50aXR5LnJlZmVyZW5jZS5rZXkuY29uY2VyZXRlQmVoYXZpb3IgfSkoeyBjb25jcmV0ZUJlaGF2aW9yTGlzdCwgZGF0YSB9KVxuICAgIGluc3RhbmNlLmtleSA9IGtleVxuICAgIHJldHVybiBpbnN0YW5jZVxuICB9LFxufSlcblxuLypcbiAgICBfX19fIF8gXyAgICAgICAgICAgIF8gICAgIF8gXyAgICAgICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgICAgXG4gICAvIF9fX3wgKF8pIF9fXyBfIF9fIHwgfF8gIChfKSB8XyBfIF9fICAgX19fIF8gX18gLyBffCBfXyBfICBfX18gX19fIFxuICB8IHwgICB8IHwgfC8gXyBcXCAnXyBcXHwgX198IHwgfCBfX3wgJ18gXFwgLyBfIFxcICdfX3wgfF8gLyBfYCB8LyBfXy8gXyBcXFxuICB8IHxfX198IHwgfCAgX18vIHwgfCB8IHxfICB8IHwgfF98IHwgfCB8ICBfXy8gfCAgfCAgX3wgKF98IHwgKF98ICBfXy9cbiAgIFxcX19fX3xffF98XFxfX198X3wgfF98XFxfX3wgfF98XFxfX3xffCB8X3xcXF9fX3xffCAgfF98ICBcXF9fLF98XFxfX19cXF9fX3xcbiovXG5Db25uZWN0aW9uLmNsaWVudEludGVyZmFjZSA9IENvbm5lY3Rpb246OlByb3RvdHlwZVtDb25zdHJ1Y3RhYmxlLnJlZmVyZW5jZS5jbGllbnRJbnRlcmZhY2UuZnVuY3Rpb25hbGl0eV0uc3dpdGNoKHtcbiAgaW1wbGVtZW50YXRpb25LZXk6IEVudGl0eS5yZWZlcmVuY2Uua2V5Lmluc3RhbmNlRGVsZWdhdGluZ1RvRW50aXR5SW5zdGFuY2VQcm90b3R5cGUsXG59KSh7XG4gIGNvbnN0cnVjdG9ySW1wbGVtZW50YXRpb246IEVudGl0eS5yZWZlcmVuY2Uua2V5LmNvbmNlcmV0ZUJlaGF2aW9yLFxufSlcbiJdfQ==