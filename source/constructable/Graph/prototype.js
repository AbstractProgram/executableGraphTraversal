"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");Object.defineProperty(exports, "__esModule", { value: true });var _exportNames = { load: true, print: true, count: true, traverse: true, traverseIterationRecursiveCallback: true, traverseGroupIterationRecursiveCall: true, traverserInstruction: true, databaseWrapper: true, schemeReference: true };exports.load = load;exports.print = print;exports.count = count;exports.traverseIterationRecursiveCallback = traverseIterationRecursiveCallback;exports.traverseGroupIterationRecursiveCall = traverseGroupIterationRecursiveCall;exports.schemeReference = exports.databaseWrapper = exports.traverserInstruction = exports.traverse = void 0;var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));var _assert = _interopRequireDefault(require("assert"));
var _proxifyMethodDecorator = require("../../utility/proxifyMethodDecorator.js");
var _removeUndefinedFromObject = require("../../utility/removeUndefinedFromObject.js");


var _TraverserClass = require("./Traverser.class.js");


var _stageNode = require("./method/stageNode.js");Object.keys(_stageNode).forEach(function (key) {if (key === "default" || key === "__esModule") return;if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;Object.defineProperty(exports, key, { enumerable: true, get: function () {return _stageNode[key];} });});
var _rerouteNode = require("./method/rerouteNode.js");Object.keys(_rerouteNode).forEach(function (key) {if (key === "default" || key === "__esModule") return;if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;Object.defineProperty(exports, key, { enumerable: true, get: function () {return _rerouteNode[key];} });});
var _forkEdge = require("./method/forkEdge.js");Object.keys(_forkEdge).forEach(function (key) {if (key === "default" || key === "__esModule") return;if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;Object.defineProperty(exports, key, { enumerable: true, get: function () {return _forkEdge[key];} });});
var _executeEdge = require("./method/executeEdge.js");Object.keys(_executeEdge).forEach(function (key) {if (key === "default" || key === "__esModule") return;if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;Object.defineProperty(exports, key, { enumerable: true, get: function () {return _executeEdge[key];} });});var _traverserInstruction = _interopRequireWildcard(require("../../traverserInstruction"));exports.traverserInstruction = _traverserInstruction;var _databaseWrapper = _interopRequireWildcard(require("../../dataModel/concreteDatabaseWrapper.js"));exports.databaseWrapper = _databaseWrapper;var _schemeReference = _interopRequireWildcard(require("../../dataModel/graphSchemeReference.js"));exports.schemeReference = _schemeReference;var _dec, _obj;





async function load({ graphData } = {}) {

  (0, _assert.default)(graphData.node && graphData.edge, `• Graph data object must contain node & edge arrays.`);
  return await this.database.loadGraphData({ nodeEntryData: graphData.node, connectionEntryData: graphData.edge });
}

async function print({} = {}) {
  console.log(`______ Graph elements: ____________________`);
  let count = await this.count();
  let allNode = await this.database.getAllNode();
  let allEdge = await this.database.getAllEdge();
  console.log(`#Vertex = ${count.node}`);
  for (let node of allNode) {
    console.log(node.identity);
  }
  console.log(`\n#Edge = ${count.connection}`);
  for (let edge of allEdge) {
    console.log(`${edge.start} --> ${edge.end}`);
  }
  console.log(`___________________________________________`);
}

async function count({} = {}) {

  return {
    node: await this.database.countNode(),
    connection: await this.database.countEdge() };

}






const { traverse } = (_dec =


(0, _proxifyMethodDecorator.proxifyMethodDecorator)(async (target, thisArg, argumentsList, targetClass, methodName) => {var _argumentsList$;

  let { nodeInstance, nodeKey, nodeID, traverser } = argumentsList[0];
  if (!nodeInstance) {
    if (nodeKey) nodeInstance = await thisArg.database.getNodeByKey({ key: nodeKey });else

      if (nodeID) nodeInstance = await thisArg.database.getNodeByID({ id: nodeID });else

        if (traverser) nodeInstance = traverser.node;else

          throw new Error('• node identifier or object must be passed in.');
    ['nodeKey', 'nodeID'].forEach(property => delete argumentsList[0][property]);
  }

  nodeInstance.entrypointNodeType = _TraverserClass.Traverser.getEntrypointNodeType({ node: nodeInstance });

  (_argumentsList$ = argumentsList[0]).nodeInstance || (_argumentsList$.nodeInstance = nodeInstance);
  return Reflect.apply(target, thisArg, argumentsList);
}), (_obj = {
  async traverse(
  {
    nodeInstance,
    implementationKey,
    evaluation,
    additionalChildNode,

    traverser,


    traversalSequenceState },

  { parentTraverser, traverseCallContext } = {})
  {
    traversalSequenceState || (traversalSequenceState = {});

    {

      traverser || (traverser = new _TraverserClass.Traverser({
        graph: this,
        node: nodeInstance,
        parentTraverser }));


      if (implementationKey) {var _implementationKey;
        traverser.setImplementationHierarchy('parameter', (_implementationKey = implementationKey, (0, _removeUndefinedFromObject.removeUndefinedFromObject)(_implementationKey)));



      }


      if (evaluation) {
        traverser.setEvaluationHierarchy('parameter', evaluation);

        delete arguments[0].evaluation;
      }


      let { implementationConfiguration, evaluationConfiguration } = await this.traverserInstruction.configurationEvaluation.resolveEvaluationConfiguration({ targetNode: traverser.node, graph: this });
      traverser.setImplementationHierarchy('configuration', implementationConfiguration);
      traverser.setEvaluationHierarchy('configuration', evaluationConfiguration);


      traverser.initialize();
    }

    let implementation = traverser.getEntrypointNodeImplementation();
    return await implementation.call(this, { traverser, additionalChildNode }, { traverseCallContext });
  } }, ((0, _applyDecoratedDescriptor2.default)(_obj, "traverse", [_dec], Object.getOwnPropertyDescriptor(_obj, "traverse"), _obj)), _obj));exports.traverse = traverse;





async function traverseIterationRecursiveCallback({ traversalIterator, additionalChildNode, traverser, traverseCallContext }) {

  let nextYielded = await traversalIterator.next({ eventEmitterCallback: (...args) => traverser.eventEmitter.emit('nodeTraversalCompleted', ...args) });
  while (!nextYielded.done)

  nextYielded = await traversalIterator.next({
    traversalPromise: this.traverse.call(this, { nodeInstance: nextYielded.value.node, additionalChildNode }, { parentTraverser: traverser, traverseCallContext }) });

  return nextYielded.value;
}







async function* traverseGroupIterationRecursiveCall({
  groupIterator,
  additionalChildNode,
  traverseCallContext,






  traverser,
  processDataCallback })
{


  for await (let { group } of groupIterator)
  yield {
    group: {
      result: await this.traverseIterationRecursiveCallback.call(this, {
        traversalIterator: group.traversalIterator,
        additionalChildNode,
        traverser,
        traverseCallContext }),

      config: {
        portNode: group.config.forkEdge.destination } } };



}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NvdXJjZS9jb25zdHJ1Y3RhYmxlL0dyYXBoL3Byb3RvdHlwZS5qcyJdLCJuYW1lcyI6WyJsb2FkIiwiZ3JhcGhEYXRhIiwibm9kZSIsImVkZ2UiLCJkYXRhYmFzZSIsImxvYWRHcmFwaERhdGEiLCJub2RlRW50cnlEYXRhIiwiY29ubmVjdGlvbkVudHJ5RGF0YSIsInByaW50IiwiY29uc29sZSIsImxvZyIsImNvdW50IiwiYWxsTm9kZSIsImdldEFsbE5vZGUiLCJhbGxFZGdlIiwiZ2V0QWxsRWRnZSIsImlkZW50aXR5IiwiY29ubmVjdGlvbiIsInN0YXJ0IiwiZW5kIiwiY291bnROb2RlIiwiY291bnRFZGdlIiwidHJhdmVyc2UiLCJ0YXJnZXQiLCJ0aGlzQXJnIiwiYXJndW1lbnRzTGlzdCIsInRhcmdldENsYXNzIiwibWV0aG9kTmFtZSIsIm5vZGVJbnN0YW5jZSIsIm5vZGVLZXkiLCJub2RlSUQiLCJ0cmF2ZXJzZXIiLCJnZXROb2RlQnlLZXkiLCJrZXkiLCJnZXROb2RlQnlJRCIsImlkIiwiRXJyb3IiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJlbnRyeXBvaW50Tm9kZVR5cGUiLCJUcmF2ZXJzZXIiLCJnZXRFbnRyeXBvaW50Tm9kZVR5cGUiLCJSZWZsZWN0IiwiYXBwbHkiLCJpbXBsZW1lbnRhdGlvbktleSIsImV2YWx1YXRpb24iLCJhZGRpdGlvbmFsQ2hpbGROb2RlIiwidHJhdmVyc2FsU2VxdWVuY2VTdGF0ZSIsInBhcmVudFRyYXZlcnNlciIsInRyYXZlcnNlQ2FsbENvbnRleHQiLCJncmFwaCIsInNldEltcGxlbWVudGF0aW9uSGllcmFyY2h5IiwicmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdCIsInNldEV2YWx1YXRpb25IaWVyYXJjaHkiLCJhcmd1bWVudHMiLCJpbXBsZW1lbnRhdGlvbkNvbmZpZ3VyYXRpb24iLCJldmFsdWF0aW9uQ29uZmlndXJhdGlvbiIsInRyYXZlcnNlckluc3RydWN0aW9uIiwiY29uZmlndXJhdGlvbkV2YWx1YXRpb24iLCJyZXNvbHZlRXZhbHVhdGlvbkNvbmZpZ3VyYXRpb24iLCJ0YXJnZXROb2RlIiwiaW5pdGlhbGl6ZSIsImltcGxlbWVudGF0aW9uIiwiZ2V0RW50cnlwb2ludE5vZGVJbXBsZW1lbnRhdGlvbiIsInRyYXZlcnNlSXRlcmF0aW9uUmVjdXJzaXZlQ2FsbGJhY2siLCJ0cmF2ZXJzYWxJdGVyYXRvciIsIm5leHRZaWVsZGVkIiwibmV4dCIsImV2ZW50RW1pdHRlckNhbGxiYWNrIiwiYXJncyIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJkb25lIiwidHJhdmVyc2FsUHJvbWlzZSIsInZhbHVlIiwidHJhdmVyc2VHcm91cEl0ZXJhdGlvblJlY3Vyc2l2ZUNhbGwiLCJncm91cEl0ZXJhdG9yIiwicHJvY2Vzc0RhdGFDYWxsYmFjayIsImdyb3VwIiwicmVzdWx0IiwiY29uZmlnIiwicG9ydE5vZGUiLCJmb3JrRWRnZSIsImRlc3RpbmF0aW9uIl0sIm1hcHBpbmdzIjoicTZCQUFBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDZVOzs7Ozs7QUFNTyxlQUFlQSxJQUFmLENBQW9CLEVBQUVDLFNBQUYsS0FBZ0IsRUFBcEMsRUFBd0M7O0FBRTdDLHVCQUFPQSxTQUFTLENBQUNDLElBQVYsSUFBa0JELFNBQVMsQ0FBQ0UsSUFBbkMsRUFBMEMsc0RBQTFDO0FBQ0EsU0FBTyxNQUFNLEtBQUtDLFFBQUwsQ0FBY0MsYUFBZCxDQUE0QixFQUFFQyxhQUFhLEVBQUVMLFNBQVMsQ0FBQ0MsSUFBM0IsRUFBaUNLLG1CQUFtQixFQUFFTixTQUFTLENBQUNFLElBQWhFLEVBQTVCLENBQWI7QUFDRDs7QUFFTSxlQUFlSyxLQUFmLENBQXFCLEtBQUssRUFBMUIsRUFBOEI7QUFDbkNDLEVBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFhLDZDQUFiO0FBQ0EsTUFBSUMsS0FBSyxHQUFHLE1BQU0sS0FBS0EsS0FBTCxFQUFsQjtBQUNBLE1BQUlDLE9BQU8sR0FBRyxNQUFNLEtBQUtSLFFB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QUowRCxFQUE5QyxDQURUOztBQU9MK0IsTUFBQUEsTUFBTSxFQUFFO0FBQ05DLFFBQUFBLFFBQVEsRUFBRUgsS0FBSyxDQUFDRSxNQUFOLENBQWFFLFFBQWIsQ0FBc0JDLFdBRDFCLEVBUEgsRUFESCxFQUFOOzs7O0FBYUgiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCdcbmltcG9ydCB7IHByb3hpZnlNZXRob2REZWNvcmF0b3IgfSBmcm9tICcuLi8uLi91dGlsaXR5L3Byb3hpZnlNZXRob2REZWNvcmF0b3IuanMnXG5pbXBvcnQgeyByZW1vdmVVbmRlZmluZWRGcm9tT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbGl0eS9yZW1vdmVVbmRlZmluZWRGcm9tT2JqZWN0LmpzJ1xuaW1wb3J0ICogYXMgQ29udGV4dCBmcm9tICcuLi9Db250ZXh0LmNsYXNzLmpzJ1xuaW1wb3J0ICogYXMgVHJhdmVyc2FsIGZyb20gJy4uL1RyYXZlcnNhbC5jbGFzcy5qcycgLy8gdHJhdmVyc2FsIGltcGxlbWVudGF0aW9uIG1hbmFnZW1lbnRcbmltcG9ydCB7IFRyYXZlcnNlciB9IGZyb20gJy4vVHJhdmVyc2VyLmNsYXNzLmpzJ1xuXG4vLyBFYWNoIGV4cG9ydGVkIHByb3BlcnR5IGVuZHMgdXAgYXMgdGhlIHByb3RvdHlwZSBwcm9wZXJ0eSBvZiB0aGUgY2xhc3MuXG5leHBvcnQgKiBmcm9tICcuL21ldGhvZC9zdGFnZU5vZGUuanMnXG5leHBvcnQgKiBmcm9tICcuL21ldGhvZC9yZXJvdXRlTm9kZS5qcydcbmV4cG9ydCAqIGZyb20gJy4vbWV0aG9kL2ZvcmtFZGdlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9tZXRob2QvZXhlY3V0ZUVkZ2UuanMnXG5leHBvcnQgKiBhcyB0cmF2ZXJzZXJJbnN0cnVjdGlvbiBmcm9tICcuLi8uLi90cmF2ZXJzZXJJbnN0cnVjdGlvbidcbmV4cG9ydCAqIGFzIGRhdGFiYXNlV3JhcHBlciBmcm9tICcuLi8uLi9kYXRhTW9kZWwvY29uY3JldGVEYXRhYmFzZVdyYXBwZXIuanMnXG5leHBvcnQgKiBhcyBzY2hlbWVSZWZlcmVuY2UgZnJvbSAnLi4vLi4vZGF0YU1vZGVsL2dyYXBoU2NoZW1lUmVmZXJlbmNlLmpzJ1xuXG4vLyBsb2FkIGdyYXBoIGludG8gbWVtb3J5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZCh7IGdyYXBoRGF0YSB9ID0ge30pIHtcbiAgLy8gbG9hZCBqc29uIGdyYXBoIGRhdGEuXG4gIGFzc2VydChncmFwaERhdGEubm9kZSAmJiBncmFwaERhdGEuZWRnZSwgYOKAoiBHcmFwaCBkYXRhIG9iamVjdCBtdXN0IGNvbnRhaW4gbm9kZSAmIGVkZ2UgYXJyYXlzLmApXG4gIHJldHVybiBhd2FpdCB0aGlzLmRhdGFiYXNlLmxvYWRHcmFwaERhdGEoeyBub2RlRW50cnlEYXRhOiBncmFwaERhdGEubm9kZSwgY29ubmVjdGlvbkVudHJ5RGF0YTogZ3JhcGhEYXRhLmVkZ2UgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByaW50KHt9ID0ge30pIHtcbiAgY29uc29sZS5sb2coYF9fX19fXyBHcmFwaCBlbGVtZW50czogX19fX19fX19fX19fX19fX19fX19gKVxuICBsZXQgY291bnQgPSBhd2FpdCB0aGlzLmNvdW50KClcbiAgbGV0IGFsbE5vZGUgPSBhd2FpdCB0aGlzLmRhdGFiYXNlLmdldEFsbE5vZGUoKVxuICBsZXQgYWxsRWRnZSA9IGF3YWl0IHRoaXMuZGF0YWJhc2UuZ2V0QWxsRWRnZSgpXG4gIGNvbnNvbGUubG9nKGAjVmVydGV4ID0gJHtjb3VudC5ub2RlfWApXG4gIGZvciAobGV0IG5vZGUgb2YgYWxsTm9kZSkge1xuICAgIGNvbnNvbGUubG9nKG5vZGUuaWRlbnRpdHkpXG4gIH1cbiAgY29uc29sZS5sb2coYFxcbiNFZGdlID0gJHtjb3VudC5jb25uZWN0aW9ufWApXG4gIGZvciAobGV0IGVkZ2Ugb2YgYWxsRWRnZSkge1xuICAgIGNvbnNvbGUubG9nKGAke2VkZ2Uuc3RhcnR9IC0tPiAke2VkZ2UuZW5kfWApXG4gIH1cbiAgY29uc29sZS5sb2coYF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19gKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY291bnQoe30gPSB7fSkge1xuICAvLyBjb3VudCBudW1iZXIgb2YgY2FjaGVkIGVsZW1lbnRzXG4gIHJldHVybiB7XG4gICAgbm9kZTogYXdhaXQgdGhpcy5kYXRhYmFzZS5jb3VudE5vZGUoKSxcbiAgICBjb25uZWN0aW9uOiBhd2FpdCB0aGlzLmRhdGFiYXNlLmNvdW50RWRnZSgpLFxuICB9XG59XG5cbi8qKiBHcmFwaCB0cmF2ZXJzYWwgaW50ZWdyYXRpb24gbGF5ZXIgKGNvcmUpIC0gQ29udHJvbHMgdGhlIHRyYXZlcnNpbmcgdGhlIG5vZGVzIGluIHRoZSBncmFwaC4gV2hpY2ggaW5jbHVkZXMgcHJvY2Vzc2luZyBvZiBkYXRhIGl0ZW1zIGFuZCBhZ2dyZWdhdGlvbiBvZiByZXN1bHRzLlxuICogRHluYW1pYyBpbXBsZW1lbnRhdGlvbiAtIG5vdCByZXN0cmljdGVkIHRvIHNwZWNpZmljIGluaXRpYWxpemF0aW9uIGFsZ29yaXRobSwgcmF0aGVyIGNob29zZW4gZnJvbSBzZXR0aW5nIG9mIGVhY2ggbm9kZSBpbiB0aGUgdHJhdmVyc2VkIGdyYXBoLlxuICogRWRnZSBmdW5jdGlvbnMgYXJlIHBhcnQgb2YgdGhlIGludGVncmF0aW9uIGxheWVyIHdoZXJlIG5vZGUgaW1wbGVtZW50YXRpb25zIGFyZSBjYWxsZWQuXG4gKi9cbi8vIE5vdGU6IHdyYXBwaW5nIGluIG9iamVjdCBhbGxvd3MgdGhlIHVzYWdlIG9mIGRlY29yYXRvcnMgYXMgdGhleSBjb3VsZG4ndCBiZSB1c2VkIG9uIHNlcGFyYXRlIGZ1bmN0aW9ucy5cbmV4cG9ydCBjb25zdCB7IHRyYXZlcnNlIH0gPSB7XG4gIC8vIEluaXRpYXRlIHRyYXZlcnNhbCBvciBhbiBleGlzdGluZyB0cmF2ZXJzYWwgc2VxdWVuY2UuXG4gIC8qKiBUaGUgYHRyYXZlcnNlYCBtZXRob2QgaXMgdXNlZCB0byB0cmF2ZXJzZSBlbnRyeXBvaW50IG5vZGVzIG9ubHkgKFN0YWdlICYgUmVyb3V0ZS9TdWJncmFwaFRlbXBsYXRlKS4gKi9cbiAgQHByb3hpZnlNZXRob2REZWNvcmF0b3IoYXN5bmMgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCwgdGFyZ2V0Q2xhc3MsIG1ldGhvZE5hbWUpID0+IHtcbiAgICAvLyBjcmVhdGUgbm9kZSBpbnN0YW5jZSwgaW4gY2FzZSBzdHJpbmcga2V5IGlzIHBhc3NlZCBhcyBwYXJhbWV0ZXIuXG4gICAgbGV0IHsgbm9kZUluc3RhbmNlIC8qIHR5cGUgTm9kZSAqLywgbm9kZUtleSwgbm9kZUlELCB0cmF2ZXJzZXIgfSA9IGFyZ3VtZW50c0xpc3RbMF1cbiAgICBpZiAoIW5vZGVJbnN0YW5jZSkge1xuICAgICAgaWYgKG5vZGVLZXkpIG5vZGVJbnN0YW5jZSA9IGF3YWl0IHRoaXNBcmcuZGF0YWJhc2UuZ2V0Tm9kZUJ5S2V5KHsga2V5OiBub2RlS2V5IH0pXG4gICAgICAvLyByZXRyaWV2ZSBub2RlIGRhdGEgb24tZGVtYW5kXG4gICAgICBlbHNlIGlmIChub2RlSUQpIG5vZGVJbnN0YW5jZSA9IGF3YWl0IHRoaXNBcmcuZGF0YWJhc2UuZ2V0Tm9kZUJ5SUQoeyBpZDogbm9kZUlEIH0pXG4gICAgICAvLyBpbiBjYXNlIGFuIGFscmVhZHkgaW5pdGlhdGVkIHRyYXZlcnNlciBpbnN0YW5jZSBpcyBwYXNzZWQuXG4gICAgICBlbHNlIGlmICh0cmF2ZXJzZXIpIG5vZGVJbnN0YW5jZSA9IHRyYXZlcnNlci5ub2RlXG4gICAgICAvLyByZXRyaWV2ZSBub2RlIGRhdGEgb24tZGVtYW5kXG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcign4oCiIG5vZGUgaWRlbnRpZmllciBvciBvYmplY3QgbXVzdCBiZSBwYXNzZWQgaW4uJylcbiAgICAgIDtbJ25vZGVLZXknLCAnbm9kZUlEJ10uZm9yRWFjaChwcm9wZXJ0eSA9PiBkZWxldGUgYXJndW1lbnRzTGlzdFswXVtwcm9wZXJ0eV0pIC8vIHJlbW92ZSBub2RlIHJlbGF0ZWQgaWRlbnRpZmllcnMuXG4gICAgfVxuICAgIC8vIFZlcmlmeSBlbnRyeXBvaW50LCBhbmQgbWFyayB0aGUgbGFiZWwgYmVpbmcgdXNlZCBhcyBlbnRyeXBvaW50IG5vZGUgdHlwZSAoYXMgbXVsdGlwbGUgZW50cnlwb2ludCBub2RlIHR5cGVzIGNvdWxkIGJlIHJlZ2lzdGVyZWQgb24gdGhlIHNhbWUgbm9kZSlcbiAgICBub2RlSW5zdGFuY2UuZW50cnlwb2ludE5vZGVUeXBlID0gVHJhdmVyc2VyLmdldEVudHJ5cG9pbnROb2RlVHlwZSh7IG5vZGU6IG5vZGVJbnN0YW5jZSB9KVxuXG4gICAgYXJndW1lbnRzTGlzdFswXS5ub2RlSW5zdGFuY2UgfHw9IG5vZGVJbnN0YW5jZSAvLyBzZXQgbm9kZSBkYXRhXG4gICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KVxuICB9KVxuICBhc3luYyB0cmF2ZXJzZShcbiAgICB7XG4gICAgICBub2RlSW5zdGFuY2UsXG4gICAgICBpbXBsZW1lbnRhdGlvbktleSxcbiAgICAgIGV2YWx1YXRpb24sXG4gICAgICBhZGRpdGlvbmFsQ2hpbGROb2RlLFxuICAgICAgLy8gY3VycmVudCBub2RlIHJlbGF0ZWQgcGFyYW1ldGVyc1xuICAgICAgdHJhdmVyc2VyLFxuICAgICAgLy8gcmVwcmVzZW50cyBhIHRyYXZlcnNhbCBzZXF1ZW5jZSB0aGF0IGhhcyBpdCdzIG93biBjYWNoZSwgYWdncmVnYXRvciwgc3RhdGlzdGljcywgYW5kIG90aGVyIHBhcmFtZXRlcnMuXG4gICAgICAvLyB0cmF2ZXJzYWwgc2VxdWVuY2UgcmVsYXRlZCBwYXJhbWV0ZXJzIC1cbiAgICAgIHRyYXZlcnNhbFNlcXVlbmNlU3RhdGUsIC8vIFRPRE86IGltcGxlbWVudCB0cmF2ZXJzYWwgc2VxdWVuY2VcbiAgICB9LFxuICAgIHsgcGFyZW50VHJhdmVyc2VyLCB0cmF2ZXJzZUNhbGxDb250ZXh0IH0gPSB7fSxcbiAgKSB7XG4gICAgdHJhdmVyc2FsU2VxdWVuY2VTdGF0ZSB8fD0ge31cblxuICAgIHtcbiAgICAgIC8vIGVhY2ggY2FsbCBjcmVhdGVzIG5ldyB0cmF2ZXJzZXIgd2l0aCBjYWxjdWxhdGlvbiBvZiB0cmF2ZXJzYWwgaW1wbGVtZW50YXRpb24gaGllcmFyY2h5ICBhbmQgcG9zaXRpb24gZXZhbHVhdGlvbiBmb3IgdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgdHJhdmVyc2VyIHx8PSBuZXcgVHJhdmVyc2VyKHtcbiAgICAgICAgZ3JhcGg6IHRoaXMsXG4gICAgICAgIG5vZGU6IG5vZGVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50VHJhdmVyc2VyLFxuICAgICAgfSlcblxuICAgICAgaWYgKGltcGxlbWVudGF0aW9uS2V5KSB7XG4gICAgICAgIHRyYXZlcnNlci5zZXRJbXBsZW1lbnRhdGlvbkhpZXJhcmNoeSgncGFyYW1ldGVyJywgaW1wbGVtZW50YXRpb25LZXkgfD4gcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdClcbiAgICAgICAgLy8gVE9ETzogQWRkIGlmIHN0YXRlbWVudCB0byBjaGVjayBmb3IgY29uZmlndXJhdGlvbiBkZXB0aCB2YWx1ZSwgd2hlcmUgaXQgY29udHJvbHMgdGhlIGVmZmVjdCBvZiB0aGUgY29uZmlndXJhdGlvcG4gb3B0aW9uIG9uIHRoZSBuZXh0IG5lc3RlZCBub2RlcyBpbiB0aGUgZ3JhcGguIGkuZS4gUGFzc2luZyB0aGUgcGFyZW50IGFyZ3VtZW50IG9yIHJlbW92aW5nIGl0LlxuICAgICAgICAvKiBmb3Igbm93LCBwYXNzIGFyZ3VtZW50IHRvIGFsbCBuZXN0ZWQgbm9kZXMgYnkgZGVmYXVsdCAoYnkgbm90IHJlbW92aW5nIHRoZSBhcmd1bWVudClcbiAgICAgIGRlbGV0ZSBhcmd1bWVudHNbMF0uaW1wbGVtZW50YXRpb25LZXkgKi9cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgYmVjYXVzZSBuYXRpdmUgT2JqZWN0LmFzc2lnbiBkb2Vzbid0IG92ZXJyaWRlIGtleXMgd2l0aCBgdW5kZWZpbmVkYCB2YWx1ZXNcbiAgICAgIGlmIChldmFsdWF0aW9uKSB7XG4gICAgICAgIHRyYXZlcnNlci5zZXRFdmFsdWF0aW9uSGllcmFyY2h5KCdwYXJhbWV0ZXInLCBldmFsdWF0aW9uKVxuICAgICAgICAvLyBUT0RPOiBBZGQgaWYgc3RhdGVtZW50IHRvIGNoZWNrIGZvciBjb25maWd1cmF0aW9uIGRlcHRoIHZhbHVlLCB3aGVyZSBpdCBjb250cm9scyB0aGUgZWZmZWN0IG9mIHRoZSBjb25maWd1cmF0aW9wbiBvcHRpb24gb24gdGhlIG5leHQgbmVzdGVkIG5vZGVzIGluIHRoZSBncmFwaC4gaS5lLiBQYXNzaW5nIHRoZSBwYXJlbnQgYXJndW1lbnQgb3IgcmVtb3ZpbmcgaXQuXG4gICAgICAgIGRlbGV0ZSBhcmd1bWVudHNbMF0uZXZhbHVhdGlvblxuICAgICAgfVxuXG4gICAgICAvLyBFdmFsdWF0aW9uIHRoYXQgYWZmZWN0cyB0aGUgdHJhdmVyc2VyIGl0c2VsZiAtIGdldCBjb25maWd1cmF0aW9uIG9mIHR5cGUgJ2V2YWx1YXRpb24nICYgJ2ltcGxlbWVudGF0aW9uJ1xuICAgICAgbGV0IHsgaW1wbGVtZW50YXRpb25Db25maWd1cmF0aW9uLCBldmFsdWF0aW9uQ29uZmlndXJhdGlvbiB9ID0gYXdhaXQgdGhpcy50cmF2ZXJzZXJJbnN0cnVjdGlvbi5jb25maWd1cmF0aW9uRXZhbHVhdGlvbi5yZXNvbHZlRXZhbHVhdGlvbkNvbmZpZ3VyYXRpb24oeyB0YXJnZXROb2RlOiB0cmF2ZXJzZXIubm9kZSwgZ3JhcGg6IHRoaXMgfSlcbiAgICAgIHRyYXZlcnNlci5zZXRJbXBsZW1lbnRhdGlvbkhpZXJhcmNoeSgnY29uZmlndXJhdGlvbicsIGltcGxlbWVudGF0aW9uQ29uZmlndXJhdGlvbilcbiAgICAgIHRyYXZlcnNlci5zZXRFdmFsdWF0aW9uSGllcmFyY2h5KCdjb25maWd1cmF0aW9uJywgZXZhbHVhdGlvbkNvbmZpZ3VyYXRpb24pXG5cbiAgICAgIC8vIHNldCBhZ2dyZWdhdG9yIHVzaW5nIG93biBjYWxjdWxhdGVkIGltcGxlbWVudGF0aW9uXG4gICAgICB0cmF2ZXJzZXIuaW5pdGlhbGl6ZSgpXG4gICAgfVxuXG4gICAgbGV0IGltcGxlbWVudGF0aW9uID0gdHJhdmVyc2VyLmdldEVudHJ5cG9pbnROb2RlSW1wbGVtZW50YXRpb24oKVxuICAgIHJldHVybiBhd2FpdCB0aGlzOjppbXBsZW1lbnRhdGlvbih7IHRyYXZlcnNlciwgYWRkaXRpb25hbENoaWxkTm9kZSB9LCB7IHRyYXZlcnNlQ2FsbENvbnRleHQgfSlcbiAgfSxcbn1cblxuLyoqIG5leHQgaXRlcmF0b3IgcmV0dXJucyBlbnRyeXBvaW50IG5vZGVzIChTdGFnZSBvciBSZXJvdXRlL1N1YmdyYXBoVGVtcGxhdGUgbm9kZXMpXG4gKiBAcGFyYW0gbm9kZUl0ZXJhdG9yIC0gaXRlcmF0b3Igb2Ygb2JqZWN0IHsgbm9kZTogPG5vZGUgZGF0YT4gfVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhdmVyc2VJdGVyYXRpb25SZWN1cnNpdmVDYWxsYmFjayh7IHRyYXZlcnNhbEl0ZXJhdG9yLCBhZGRpdGlvbmFsQ2hpbGROb2RlLCB0cmF2ZXJzZXIsIHRyYXZlcnNlQ2FsbENvbnRleHQgfSkge1xuICAvLyBmaXJzdCBjYWxsIGlzIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZnVuY3Rpb24gKHVzaW5nIG5vbi1zdGFuZGFyZCBmdW5jdGlvbi5zZW50KVxuICBsZXQgbmV4dFlpZWxkZWQgPSBhd2FpdCB0cmF2ZXJzYWxJdGVyYXRvci5uZXh0KHsgZXZlbnRFbWl0dGVyQ2FsbGJhY2s6ICguLi5hcmdzKSA9PiB0cmF2ZXJzZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ25vZGVUcmF2ZXJzYWxDb21wbGV0ZWQnLCAuLi5hcmdzKSB9KVxuICB3aGlsZSAoIW5leHRZaWVsZGVkLmRvbmUpXG4gICAgLy8g8J+UgSByZWN1cnNpb24gdHJhdmVyc2FsIGNhbGwgKHdpdGggbmV4dCBub2RlKVxuICAgIG5leHRZaWVsZGVkID0gYXdhaXQgdHJhdmVyc2FsSXRlcmF0b3IubmV4dCh7XG4gICAgICB0cmF2ZXJzYWxQcm9taXNlOiB0aGlzOjp0aGlzLnRyYXZlcnNlKHsgbm9kZUluc3RhbmNlOiBuZXh0WWllbGRlZC52YWx1ZS5ub2RlIC8qIG5leHQgbm9kZSAqLywgYWRkaXRpb25hbENoaWxkTm9kZSB9LCB7IHBhcmVudFRyYXZlcnNlcjogdHJhdmVyc2VyLCB0cmF2ZXJzZUNhbGxDb250ZXh0IH0pLFxuICAgIH0pXG4gIHJldHVybiBuZXh0WWllbGRlZC52YWx1ZSAvLyBsYXN0IHlpZWxkZWQgdmFsdWUgaXMgdGhlIHJlc3VsdCBhcnJheS5cbn1cblxuLyoqXG4gKiBDb250cm9scyBleGVjdXRpb24gb2Ygbm9kZSB0cmF2ZXJzYWxzICYgSGFuZHMgb3ZlciBjb250cm9sIHRvIGltcGxlbWVudGF0aW9uOlxuICogIDEuIEFjY2VwdHMgbmV3IG5vZGVzIGZyb20gaW1wbGVtZW50aW5nIGZ1bmN0aW9uLlxuICogIDIuIHJldHVybnMgYmFjayB0byB0aGUgaW1wbGVtZW50aW5nIGZ1bmN0aW9uIGEgcHJvbWlzZSwgaGFuZGluZyBjb250cm9sIG9mIGZsb3cgYW5kIGFycmFnZW1lbnQgb2YgcnVubmluZyB0cmF2ZXJzYWxzLlxuICogQHJldHVybiB7aXRlcmF0b3IgZmVlZCBvZiBvYmplY3R9IC0ge2NvbmZpZzogeyBwb3J0OiA8cG9ydCBub2RlPiB9LCByZXN1bHQ6IDxhcnJheSBvZiBuZXh0IG5vZGVzPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiB0cmF2ZXJzZUdyb3VwSXRlcmF0aW9uUmVjdXJzaXZlQ2FsbCh7XG4gIGdyb3VwSXRlcmF0b3IgLyoqIEZlZWRpbmcgaXRlcmF0b3IgdGhhdCB3aWxsIGFjY2VwdCBub2RlIHBhcmFtZXRlcnMgZm9yIHRyYXZlcnNhbHMgKi8sXG4gIGFkZGl0aW9uYWxDaGlsZE5vZGUsXG4gIHRyYXZlcnNlQ2FsbENvbnRleHQsXG4gIC8qKiBcbiAgICBJbXBvcnRhbnQgTm90ZTogIFxuICAgIEJlbG93IHBhcmFtZXRlcnMgYXJlIHVzZWQgaW4gdGhlIGludGVyY2VwdGlvbiBwcm94eSB0byBkZWNpZGUgd2hhdCB0byB0cmF2ZXJzZSBhbmQgaG93IHRvIGFnZ3JlZ2F0ZSB0aGUgcmVzdWx0cy4gXG4gICAgYFRyYXZlcnNhbCBjb25maWdgIGluIHRoZSBpbnRlcmNlcHRpb24gd2lsbCBsaW1pdCB0aGUgdHJhdmVyc2FsIGFuZCBwcm9jZXNzaW5nLCBpLmUuIGl0IGRlY2lkZXMgaWYgdG8gcHJvY2VzcyBjdXJyZW50IG5vZGUsIGlmIHRvIGluY2x1ZGUgaXQgdG8gYWdncmFnYXRpb24sIGFuZCBpZiB0byB0cmF2ZXJzZSB0aGUgbmVzdGVkIG5vZGVzLlxuICAgIElmIGludGVyY2VwdGlvbiBwcm94eSBpcyBleGNsdWRlZCAobm8gaW1wbGVtZW50YXRpb24gc2V0KSwgdGhlIGdyYXBoIHNob3VsZCB0cmF2ZXJzZSBhbGwgbm9kZXMgd2l0aCBubyByZXN0cmljdGlvbnMuXG4gICovXG4gIHRyYXZlcnNlcixcbiAgcHJvY2Vzc0RhdGFDYWxsYmFjayxcbn0pIHtcbiAgLy8gcG9ydCB0cmF2ZXJzYWwgcmVzdWx0IC0gbGFzdCBub2RlIGl0ZXJhdG9yIGZlZWQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHJlc29sdmVkIG5vZGUgcHJvbWlzZXMgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0aHJvdWdoIHRoaXMgZnVuY3Rpb25cbiAgLy8gZm9yd2FyZCBhcnJheSBvZiByZXNvbHZlZCByZXN1bHRzXG4gIGZvciBhd2FpdCAobGV0IHsgZ3JvdXAgfSBvZiBncm91cEl0ZXJhdG9yKVxuICAgIHlpZWxkIHtcbiAgICAgIGdyb3VwOiB7XG4gICAgICAgIHJlc3VsdDogYXdhaXQgdGhpczo6dGhpcy50cmF2ZXJzZUl0ZXJhdGlvblJlY3Vyc2l2ZUNhbGxiYWNrKHtcbiAgICAgICAgICB0cmF2ZXJzYWxJdGVyYXRvcjogZ3JvdXAudHJhdmVyc2FsSXRlcmF0b3IsXG4gICAgICAgICAgYWRkaXRpb25hbENoaWxkTm9kZSxcbiAgICAgICAgICB0cmF2ZXJzZXIsXG4gICAgICAgICAgdHJhdmVyc2VDYWxsQ29udGV4dCxcbiAgICAgICAgfSksXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIHBvcnROb2RlOiBncm91cC5jb25maWcuZm9ya0VkZ2UuZGVzdGluYXRpb24sIC8vIHRoZSByZWxhdGVkIHBvcnQgd2hpY2ggdGhlIHN0YWdlIG9yaWdpbmF0ZWQgZnJvbS5cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxufVxuIl19