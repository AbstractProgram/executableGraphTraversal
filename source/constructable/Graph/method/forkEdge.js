"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.forkEdge = forkEdge;var _skipFirstGeneratorNext2 = _interopRequireDefault(require("@babel/runtime/helpers/skipFirstGeneratorNext"));var _assert = _interopRequireDefault(require("assert"));
var _promiseProperRace = _interopRequireDefault(require("@dependency/promiseProperRace"));








async function* forkEdge({ stageNode, additionalChildNode, getImplementation, graphInstance = this }) {
  const { forkArray } = await graphInstance.databaseWrapper.getFork({ concreteDatabase: graphInstance.database, nodeID: stageNode.identity });
  if (forkArray.length == 0) return;

  forkArray.sort((former, latter) => former.connection.properties.order - latter.connection.properties.order);

  for (let forkEdge of forkArray) {
    (0, _assert.default)(forkEdge.destination.labels.includes(graphInstance.schemeReference.nodeLabel.port), `‚Ä¢ "${forkEdge.destination.labels}" Unsupported node type for a FORK connection.`);


    let implementation = getImplementation(forkEdge.destination.properties.implementation);
    let nodeIteratorFeed = implementation.call(graphInstance, { forkEdge, additionalChildNode, graphInstance });

    let traversalIterator = traversalIterator2WayCommunication({
      nodeIteratorFeed,
      implementation: handlePropagation[forkEdge.connection.properties.handlePropagationImplementation || 'chronological'] });


    yield {
      group: {
        traversalIterator,

        config: {
          forkEdge } } };



  }
}let _original_traversalIterator2WayCommunication = async function*










traversalIterator2WayCommunication({ nodeIteratorFeed, implementation }) {let _functionSent = yield;
  let { eventEmitterCallback } = _functionSent;

  let traversalIteratorFeed = implementation({ nodeIteratorFeed, emit: eventEmitterCallback });

  let iteratorObject = await traversalIteratorFeed.next();
  while (!iteratorObject.done) {
    _functionSent = yield { node: iteratorObject.value.node };
    iteratorObject = await traversalIteratorFeed.next({ traversalPromise: _functionSent.traversalPromise });
  }
  return iteratorObject.value;
},_modified_traversalIterator2WayCommunication = (0, _skipFirstGeneratorNext2.default)(_original_traversalIterator2WayCommunication);let traversalIterator2WayCommunication;traversalIterator2WayCommunication = new Proxy(_original_traversalIterator2WayCommunication, { apply(target, thisArgument, argumentsList) {return Reflect.apply(_modified_traversalIterator2WayCommunication, thisArgument, argumentsList);} });











const handlePropagation = {



  chronological: (function () {let _ref = async function* ({ nodeIteratorFeed, emit }) {let _functionSent2 = yield;
      let nodeResultList = [];
      for await (let { node } of nodeIteratorFeed) {
        _functionSent2 = yield { node };
        let nextResult = await _functionSent2.traversalPromise;
        emit(nextResult);
        nodeResultList.push(nextResult);
      }
      return nodeResultList;
    },_ref2 = (0, _skipFirstGeneratorNext2.default)(_ref);return new Proxy(_ref, { apply(target, thisArgument, argumentsList) {return Reflect.apply(_ref2, thisArgument, argumentsList);} });})(),

  chronological_implementationUsingWhileLoop: (function () {let _ref4 = async function* ({ nodeIteratorFeed, emit }) {let _functionSent3 = yield;
      let nodeResultList = [];

      let iteratorObject = await nodeIteratorFeed.next();
      while (!iteratorObject.done) {
        _functionSent3 = yield { node: iteratorObject.value.node };
        let nextResult = await _functionSent3.traversalPromise;
        emit(nextResult);
        nodeResultList.push(nextResult);
        iteratorObject = await nodeIteratorFeed.next();
      }

      return nodeResultList;
    },_ref5 = (0, _skipFirstGeneratorNext2.default)(_ref4);return new Proxy(_ref4, { apply(target, thisArgument, argumentsList) {return Reflect.apply(_ref5, thisArgument, argumentsList);} });})(),




  raceFirstPromise: (function () {let _ref7 = async function* ({ nodeIteratorFeed, emit }) {let _functionSent4 = yield;
      let nodePromiseArray = [];

      let iteratorObject = await nodeIteratorFeed.next();
      while (!iteratorObject.done) {
        _functionSent4 = yield { node: iteratorObject.value.node };
        let traversalPromise = _functionSent4.traversalPromise;
        nodePromiseArray.push(traversalPromise);
        iteratorObject = await nodeIteratorFeed.next();
      }

      let nodeResolvedResult = await (0, _promiseProperRace.default)(nodePromiseArray).
      then(resolvedPromiseArray => {
        return resolvedPromiseArray[0];
      }).
      catch(error => {

        console.error(`üîÄ‚ö†Ô∏è promiseProperRace rejected because: ${error}`);
      });

      if (nodeResolvedResult) {
        emit(nodeResolvedResult);
        return [nodeResolvedResult];
      } else return [];
    },_ref8 = (0, _skipFirstGeneratorNext2.default)(_ref7);return new Proxy(_ref7, { apply(target, thisArgument, argumentsList) {return Reflect.apply(_ref8, thisArgument, argumentsList);} });})(),




  allPromise: (function () {let _ref10 = async function* ({ nodeIteratorFeed, emit }) {let _functionSent5 = yield;
      let nodePromiseArray = [];
      let resolvedOrderedNodeResolvedResult = [];

      let iteratorObject = await nodeIteratorFeed.next();
      while (!iteratorObject.done) {
        _functionSent5 = yield { node: iteratorObject.value.node };
        let traversalPromise = _functionSent5.traversalPromise.then(result => {
          emit(result);
          resolvedOrderedNodeResolvedResult.push(result);
        });
        nodePromiseArray.push(traversalPromise);
        iteratorObject = await nodeIteratorFeed.next();
      }


      let nodeResolvedResultArray = await Promise.all(nodePromiseArray).catch(error => {
        if (process.env.SZN_DEBUG == 'true') console.error(`üîÄ‚ö†Ô∏è \`Promise.all\` for nodeConnectionArray rejected because: ${error}`);else
        console.log(error);
      });


      return resolvedOrderedNodeResolvedResult;





    },_ref11 = (0, _skipFirstGeneratorNext2.default)(_ref10);return new Proxy(_ref10, { apply(target, thisArgument, argumentsList) {return Reflect.apply(_ref11, thisArgument, argumentsList);} });})() };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NvdXJjZS9jb25zdHJ1Y3RhYmxlL0dyYXBoL21ldGhvZC9mb3JrRWRnZS5qcyJdLCJuYW1lcyI6WyJmb3JrRWRnZSIsInN0YWdlTm9kZSIsImFkZGl0aW9uYWxDaGlsZE5vZGUiLCJnZXRJbXBsZW1lbnRhdGlvbiIsImdyYXBoSW5zdGFuY2UiLCJmb3JrQXJyYXkiLCJkYXRhYmFzZVdyYXBwZXIiLCJnZXRGb3JrIiwiY29uY3JldGVEYXRhYmFzZSIsImRhdGFiYXNlIiwibm9kZUlEIiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJzb3J0IiwiZm9ybWVyIiwibGF0dGVyIiwiY29ubmVjdGlvbiIsInByb3BlcnRpZXMiLCJvcmRlciIsImRlc3RpbmF0aW9uIiwibGFiZWxzIiwiaW5jbHVkZXMiLCJzY2hlbWVSZWZlcmVuY2UiLCJub2RlTGFiZWwiLCJwb3J0IiwiaW1wbGVtZW50YXRpb24iLCJub2RlSXRlcmF0b3JGZWVkIiwidHJhdmVyc2FsSXRlcmF0b3IiLCJ0cmF2ZXJzYWxJdGVyYXRvcjJXYXlDb21tdW5pY2F0aW9uIiwiaGFuZGxlUHJvcGFnYXRpb24iLCJoYW5kbGVQcm9wYWdhdGlvbkltcGxlbWVudGF0aW9uIiwiZ3JvdXAiLCJjb25maWciLCJldmVudEVtaXR0ZXJDYWxsYmFjayIsInRyYXZlcnNhbEl0ZXJhdG9yRmVlZCIsImVtaXQiLCJpdGVyYXRvck9iamVjdCIsIm5leHQiLCJkb25lIiwibm9kZSIsInZhbHVlIiwidHJhdmVyc2FsUHJvbWlzZSIsImNocm9ub2xvZ2ljYWwiLCJub2RlUmVzdWx0TGlzdCIsIm5leHRSZXN1bHQiLCJwdXNoIiwiY2hyb25vbG9naWNhbF9pbXBsZW1lbnRhdGlvblVzaW5nV2hpbGVMb29wIiwicmFjZUZpcnN0UHJvbWlzZSIsIm5vZGVQcm9taXNlQXJyYXkiLCJub2RlUmVzb2x2ZWRSZXN1bHQiLCJ0aGVuIiwicmVzb2x2ZWRQcm9taXNlQXJyYXkiLCJjYXRjaCIsImVycm9yIiwiY29uc29sZSIsImFsbFByb21pc2UiLCJyZXNvbHZlZE9yZGVyZWROb2RlUmVzb2x2ZWRSZXN1bHQiLCJyZXN1bHQiLCJub2RlUmVzb2x2ZWRSZXN1bHRBcnJheSIsIlByb21pc2UiLCJhbGwiLCJwcm9jZXNzIiwiZW52IiwiU1pOX0RFQlVHIiwibG9nIl0sIm1hcHBpbmdzIjoiNFNBQUE7QUFDQTs7Ozs7Ozs7O0FBU08sZ0JBQWdCQSxRQUFoQixDQUF5QixFQUFFQyxTQUFGLEVBQWFDLG1CQUFiLEVBQWtDQyxpQkFBbEMsRUFBcURDLGFBQWEsR0FBRyxJQUFyRSxFQUF6QixFQUFzRztBQUMzRyxRQUFNLEVBQUVDLFNBQUYsS0FBZ0IsTUFBTUQsYUFBYSxDQUFDRSxlQUFkLENBQThCQyxPQUE5QixDQUFzQyxFQUFFQyxnQkFBZ0IsRUFBRUosYUFBYSxDQUFDSyxRQUFsQyxFQUE0Q0MsTUFBTSxFQUFFVCxTQUFTLENBQUNVLFFBQTlELEVBQXRDLENBQTVCO0FBQ0EsTUFBSU4sU0FBUyxDQUFDTyxNQUFWLElBQW9CLENBQXhCLEVBQTJCOztBQUUzQlAsRUFBQUEsU0FBUyxDQUFDUSxJQUFWLENBQWUsQ0FBQ0MsTUFBRCxFQUFTQyxNQUFULEtBQW9CRCxNQUFNLENBQUNFLFVBQVAsQ0FBa0JDLFVBQWxCLENBQTZCQyxLQUE3QixHQUFxQ0gsTUFBTSxDQUFDQyxVQUFQLENBQWtCQyxVQUFsQixDQUE2QkMsS0FBckc7O0FBRUEsT0FBSyxJQUFJbEIsUUFBVCxJQUFxQkssU0FBckIsRUFBZ0M7QUFDOUIseUJBQU9MLFFBQVEsQ0FBQ21CLFdBQVQsQ0FBcUJDLE1BQXJCLENBQTRCQyxRQUE1QixDQUFxQ2pCLGFBQWEsQ0FBQ2tCLGVBQWQsQ0FBOEJDLFNBQTlCLENBQXdDQyxJQUE3RSxDQUFQLEVBQTRGLE1BQUt4QixRQUFRLENBQUNtQixXQUFULENBQXFCQyxNQUFPLGdEQUE3SDs7O0FBR0EsUUFBSUssY0FBYyxHQUFHdEIsaUJBQWlCLENBQUNILFFBQVEsQ0FBQ21CLFdBQVQsQ0FBcUJGLFVBQXJCLENBQWdDUSxjQUFq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QWMsQ0FBQ0ksS0FBZixDQUFxQkQsSUFBN0IsRUFBTjtBQUNBLFlBQUlFLGdCQUFnQixHQUFHLGVBQWNBLGdCQUFkLENBQStCUyxJQUEvQixDQUFvQ08sTUFBTSxJQUFJO0FBQ25FdEIsVUFBQUEsSUFBSSxDQUFDc0IsTUFBRCxDQUFKO0FBQ0FELFVBQUFBLGlDQUFpQyxDQUFDWCxJQUFsQyxDQUF1Q1ksTUFBdkM7QUFDRCxTQUhzQixDQUF2QjtBQUlBVCxRQUFBQSxnQkFBZ0IsQ0FBQ0gsSUFBakIsQ0FBc0JKLGdCQUF0QjtBQUNBTCxRQUFBQSxjQUFjLEdBQUcsTUFBTVYsZ0JBQWdCLENBQUNXLElBQWpCLEVBQXZCO0FBQ0Q7OztBQUdELFVBQUlxQix1QkFBdUIsR0FBRyxNQUFNQyxPQUFPLENBQUNDLEdBQVIsQ0FBWVosZ0JBQVosRUFBOEJJLEtBQTlCLENBQW9DQyxLQUFLLElBQUk7QUFDL0UsWUFBSVEsT0FBTyxDQUFDQyxHQUFSLENBQVlDLFNBQVosSUFBeUIsTUFBN0IsRUFBcUNULE9BQU8sQ0FBQ0QsS0FBUixDQUFlLGtFQUFpRUEsS0FBTSxFQUF0RixFQUFyQztBQUNLQyxRQUFBQSxPQUFPLENBQUNVLEdBQVIsQ0FBWVgsS0FBWjtBQUNOLE9BSG1DLENBQXBDOzs7QUFNQSxhQUFPRyxpQ0FBUDs7Ozs7O0FBTUQsS0E1QlMsa01BOURjLEVBQTFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnXG5pbXBvcnQgcHJvbWlzZVByb3BlclJhY2UgZnJvbSAnQGRlcGVuZGVuY3kvcHJvbWlzZVByb3BlclJhY2UnXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIGxvb3BzIHRocm91Z2ggYWxsIHRoZSBgbm9kZSBwb3J0c2AgYW5kIGluaXRpYWxpemVzIGVhY2ggb25lIHRvIGV4ZWN1dGUgdGhlIGBub2RlIGNvbm5lY3Rpb25zYCBzcGVjaWZpYyBmb3IgaXQuXG4gKiBAeWllbGQgIHtpdGVyYXRvciBmZWVkIG9mIG9iamVjdH0gbm9kZXMgZ3JvdXAgb2JqZWN0IC0gbmVzdGVkIG9iamVjdCBjb250YWluaW5nIEZvcmsvUG9ydCBpdGVyYXRvciB3aXRoIG5lc3RlZCBOZXh0L1N0YWdlIGl0ZXJhdG9yIGZvciBlYWNoLlxuICogVE9ETzogYWRkIGFiaWxpdHkgdG8gcGFzcyB0cmF2ZXJzYWwgY29uZmlndXJhdGlvbiB0byBhIGdyb3VwIG9mIGNvbm5lY3Rpb25zLiBFYWNoIHBvcnQgaG9sZHMgdHJhdmVyc2FsIGNvZmlncyB0aGF0IHNob3VsZCBhZmZlY3QgYWxsIGNvbm5lY3Rpb24gY29ubmVjdGVkIHRvIHRoaXMgcG9ydC5cbiAqIE9SXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IGluIGNhc2Ugbm8gZm9ya3MuXG4gKiovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGZvcmtFZGdlKHsgc3RhZ2VOb2RlLCBhZGRpdGlvbmFsQ2hpbGROb2RlLCBnZXRJbXBsZW1lbnRhdGlvbiwgZ3JhcGhJbnN0YW5jZSA9IHRoaXMgfSkge1xuICBjb25zdCB7IGZvcmtBcnJheSB9ID0gYXdhaXQgZ3JhcGhJbnN0YW5jZS5kYXRhYmFzZVdyYXBwZXIuZ2V0Rm9yayh7IGNvbmNyZXRlRGF0YWJhc2U6IGdyYXBoSW5zdGFuY2UuZGF0YWJhc2UsIG5vZGVJRDogc3RhZ2VOb2RlLmlkZW50aXR5IH0pXG4gIGlmIChmb3JrQXJyYXkubGVuZ3RoID09IDApIHJldHVyblxuICAvLyBCdWxrIGFjdGlvbnMgb24gZm9ya3MgLSBzb3J0IGZvcmtzXG4gIGZvcmtBcnJheS5zb3J0KChmb3JtZXIsIGxhdHRlcikgPT4gZm9ybWVyLmNvbm5lY3Rpb24ucHJvcGVydGllcy5vcmRlciAtIGxhdHRlci5jb25uZWN0aW9uLnByb3BlcnRpZXMub3JkZXIpIC8vIHVzaW5nIGBvcmRlcmAgcHJvcGVydHlcblxuICBmb3IgKGxldCBmb3JrRWRnZSBvZiBmb3JrQXJyYXkpIHtcbiAgICBhc3NlcnQoZm9ya0VkZ2UuZGVzdGluYXRpb24ubGFiZWxzLmluY2x1ZGVzKGdyYXBoSW5zdGFuY2Uuc2NoZW1lUmVmZXJlbmNlLm5vZGVMYWJlbC5wb3J0KSwgYOKAoiBcIiR7Zm9ya0VkZ2UuZGVzdGluYXRpb24ubGFiZWxzfVwiIFVuc3VwcG9ydGVkIG5vZGUgdHlwZSBmb3IgYSBGT1JLIGNvbm5lY3Rpb24uYCkgLy8gdmVyaWZ5IG5vZGUgdHlwZVxuXG4gICAgLy8gdGhlIGZpcnN0IGl0ZXJhdG9yIG9iamVjdCBjYWxsIGlzIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZnVuY3Rpb24sIGluIGFkZGl0aW9uIHRvIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBjYWxsLlxuICAgIGxldCBpbXBsZW1lbnRhdGlvbiA9IGdldEltcGxlbWVudGF0aW9uKGZvcmtFZGdlLmRlc3RpbmF0aW9uLnByb3BlcnRpZXMuaW1wbGVtZW50YXRpb24pIC8vIFRyYXZlcnNhbCBpbXBsZW1lbnRhdGlvbiAtIG5vZGUvZWRnZSBwcm9wZXJ0aWVzIGltcGxlbWVudGF0aW9uIGhpZXJhcmNoeSAtIGNhbGN1bGF0ZSBhbmQgcGljayBjb3JyZWN0IGltcGxlbWVudGF0aW9uIGFjY29yZGluZyB0byBwYXJhbWV0ZXIgaGllcmFyY2h5LlxuICAgIGxldCBub2RlSXRlcmF0b3JGZWVkID0gZ3JhcGhJbnN0YW5jZTo6aW1wbGVtZW50YXRpb24oeyBmb3JrRWRnZSwgYWRkaXRpb25hbENoaWxkTm9kZSwgZ3JhcGhJbnN0YW5jZSB9KVxuXG4gICAgbGV0IHRyYXZlcnNhbEl0ZXJhdG9yID0gdHJhdmVyc2FsSXRlcmF0b3IyV2F5Q29tbXVuaWNhdGlvbih7XG4gICAgICBub2RlSXRlcmF0b3JGZWVkLFxuICAgICAgaW1wbGVtZW50YXRpb246IGhhbmRsZVByb3BhZ2F0aW9uW2ZvcmtFZGdlLmNvbm5lY3Rpb24ucHJvcGVydGllcy5oYW5kbGVQcm9wYWdhdGlvbkltcGxlbWVudGF0aW9uIHx8ICdjaHJvbm9sb2dpY2FsJ10sXG4gICAgfSlcblxuICAgIHlpZWxkIHtcbiAgICAgIGdyb3VwOiB7XG4gICAgICAgIHRyYXZlcnNhbEl0ZXJhdG9yLCAvLyBuZXh0IG5vZGVzIGl0ZXJhdG9yIHdpdGggcmVjZWl2aW5nIHByb21pc2Ugb2Ygbm9kZSB0cmF2ZXJzYWxcbiAgICAgICAgLy8gbm9kZXMgZ3JvdXAgaW5mb3JtYXRpb25cbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgZm9ya0VkZ2UsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxufVxuXG4vKiogQXN5bmMgZ2VuZXJhdG9yIHRyYXAgKGFsbCBwb3J0IHByb3BhZ2F0aW9uIGhhbmRsZXJzIHBhc3MgdGhyb3VnaCB0aGlzIHRyYXApIHdoaWNoIHZlcmlmaWVzIHRoYXQgYWxsIHBvcnQgaW1wbGVtZW50YXRpb25zIGZvbGxvdyBhIDIgd2F5IGl0ZXJhdG9yIGNvbW11bmljYXRpb24uXG4gKiBAcmVjZWl2ZSBbZnVuY3Rpb24uc2VudF0gT2JqZWN0IHsgZXZlbnRFbWl0dGVyQ2FsbGJhY2s6IDxmdW5jdGlvbiBlbWl0dGluZyBhIHRyYXZlcnNhbCBjb21wbGV0ZSBldmVudD4gfSAtIGR1cmluZyBpdGVyYXRvciBpbml0aWFsaXphdGlvbi5cbiAqXG4gKiBJdGVyYXRpb24gMiB3YXkgY29tbXVuaWNhdGlvbjpcbiAqIDEuIEB5aWVsZCBvYmplY3QgeyBub2RlOiA8bm9kZSBkYXRhPiB9XG4gKiAyLiBAcmVjaWV2ZSBbZnVuY3Rpb24uc2VudF0gb2JqZWN0IHsgdHJhdmVyc2FsUHJvbWlzZSB9XG4gKlxuICogQHJldHVybiB7QXJyYXl9IHJlc3VsdHMgYXJyYXlcbiAqL1xuYXN5bmMgZnVuY3Rpb24qIHRyYXZlcnNhbEl0ZXJhdG9yMldheUNvbW11bmljYXRpb24oeyBub2RlSXRlcmF0b3JGZWVkLCBpbXBsZW1lbnRhdGlvbiB9KSB7XG4gIGxldCB7IGV2ZW50RW1pdHRlckNhbGxiYWNrIH0gPSBmdW5jdGlvbi5zZW50XG5cbiAgbGV0IHRyYXZlcnNhbEl0ZXJhdG9yRmVlZCA9IGltcGxlbWVudGF0aW9uKHsgbm9kZUl0ZXJhdG9yRmVlZCwgZW1pdDogZXZlbnRFbWl0dGVyQ2FsbGJhY2sgfSkgLy8gcGFzcyBpdGVyYXRvciB0byBpbXBsZW1lbnRhdGlvbiBhbmQgcHJvcGFnYXRlIGJhY2sgKHRocm91Z2ggcmV0dXJuIHN0YXRlbWVudCkgdGhlIHJlc3VsdHMgb2YgdGhlIG5vZGUgcHJvbWlzZXMgYWZ0ZXIgY29tcGxldGlvblxuXG4gIGxldCBpdGVyYXRvck9iamVjdCA9IGF3YWl0IHRyYXZlcnNhbEl0ZXJhdG9yRmVlZC5uZXh0KClcbiAgd2hpbGUgKCFpdGVyYXRvck9iamVjdC5kb25lKSB7XG4gICAgeWllbGQgeyBub2RlOiBpdGVyYXRvck9iamVjdC52YWx1ZS5ub2RlIH1cbiAgICBpdGVyYXRvck9iamVjdCA9IGF3YWl0IHRyYXZlcnNhbEl0ZXJhdG9yRmVlZC5uZXh0KHsgdHJhdmVyc2FsUHJvbWlzZTogZnVuY3Rpb24uc2VudC50cmF2ZXJzYWxQcm9taXNlIH0pXG4gIH1cbiAgcmV0dXJuIGl0ZXJhdG9yT2JqZWN0LnZhbHVlXG59XG5cbi8qKlxuICogTWV0aG9kcyBjb250cm9sbGluZyB0aGUgaXRlcmF0aW9uIG92ZXIgbm9kZXMgYW5kIGV4ZWN1dGlvbiBhcnJhbmdlbWVudC5cbiAqIFByb3BhZ2F0aW9uIENvbnRyb2wgaW1wbGVtZW50YXRpb24gLSBIYW5kbGVzIHRoZSBncmFwaCB0cmF2ZXJzYWwgcHJvcGFnYXRpb24gb3JkZXIgb2YgTmV4dCBub2RlczogXG4gICAgLSBQYXJhbGxlbFxuICAgIC0gQ2hyb25vbG9naWNhbFxuICAgIC0gUmFjZSBmaXJzdFxuICAgIC0gZXRjLi4uXG4gKiBAcGFyYW0gbm9kZUl0ZXJhdG9yRmVlZCBpdGVyYXRvciBvZiBvYmplY3Qge25vZGU6PG5vZGUgZGF0YT59XG4gKiBAcGFyYW0gZW1pdCBldmVudCBlbWl0dGVyIGNhbGxiYWNrIHVzZWQgdG8gaW5kaWNhdGUgaW1tZWRpYXRlIHJlc29sdXRpb24gb2Ygbm9kZSB0cmF2ZXJzYWwgcHJvbWlzZSAoaS5lLiB3aGVuIHRoZSBub2RlIGNvbXBsZXRlcyBpdCdzIHRyYXZlcnNhbCkuXG4gKi9cbmNvbnN0IGhhbmRsZVByb3BhZ2F0aW9uID0ge1xuICAvKipcbiAgICogU2VxdWVudGlhbCBub2RlIGV4ZWN1dGlvbiAtIGF3YWl0IGVhY2ggbm9kZSB0aWxsIGl0IGZpbmlzaGVzIGV4ZWN1dGlvbi5cbiAgICoqL1xuICBjaHJvbm9sb2dpY2FsOiBhc3luYyBmdW5jdGlvbiooeyBub2RlSXRlcmF0b3JGZWVkLCBlbWl0IH0pIHtcbiAgICBsZXQgbm9kZVJlc3VsdExpc3QgPSBbXVxuICAgIGZvciBhd2FpdCAobGV0IHsgbm9kZSB9IG9mIG5vZGVJdGVyYXRvckZlZWQpIHtcbiAgICAgIHlpZWxkIHsgbm9kZSB9XG4gICAgICBsZXQgbmV4dFJlc3VsdCA9IGF3YWl0IGZ1bmN0aW9uLnNlbnQudHJhdmVyc2FsUHJvbWlzZVxuICAgICAgZW1pdChuZXh0UmVzdWx0KSAvLyBlbWl0IGZvciBpbW1lZGlhdGUgY29uc3VtcHRpb25cbiAgICAgIG5vZGVSZXN1bHRMaXN0LnB1c2gobmV4dFJlc3VsdClcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVSZXN1bHRMaXN0XG4gIH0sXG4gIC8vIE5vdGU6IGtlcHQgZm9yIGZ1dHVyZSByZWZlcmVuY2UuIEltcGxlbWVudGF0aW9uIHVzaW5nIHdoaWxlIGxvb3AgaW5zdGVhZCBvZiBgZm9yIGF3YWl0YCwgYXMgaXQgYWxsb3dzIGZvciBwYXNzaW5nIGluaXRpYWwgY29uZmlnIHZhbHVlIGZvciB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uICh0aGF0IHdpbGwgdXNlIGZ1bmN0aW9uLnNlbnQgdG8gY2F0Y2ggaXQuKVxuICBjaHJvbm9sb2dpY2FsX2ltcGxlbWVudGF0aW9uVXNpbmdXaGlsZUxvb3A6IGFzeW5jIGZ1bmN0aW9uKih7IG5vZGVJdGVyYXRvckZlZWQsIGVtaXQgfSkge1xuICAgIGxldCBub2RlUmVzdWx0TGlzdCA9IFtdXG5cbiAgICBsZXQgaXRlcmF0b3JPYmplY3QgPSBhd2FpdCBub2RlSXRlcmF0b3JGZWVkLm5leHQoKSAvLyBpbml0aWFsaXplIGdlbmVyYXRvciBmdW5jdGlvbiBleGVjdXRpb24gYW5kIHBhc3MgZXhlY3V0aW9uIGNvbmZpZ3VyYXRpb25zLlxuICAgIHdoaWxlICghaXRlcmF0b3JPYmplY3QuZG9uZSkge1xuICAgICAgeWllbGQgeyBub2RlOiBpdGVyYXRvck9iamVjdC52YWx1ZS5ub2RlIH1cbiAgICAgIGxldCBuZXh0UmVzdWx0ID0gYXdhaXQgZnVuY3Rpb24uc2VudC50cmF2ZXJzYWxQcm9taXNlXG4gICAgICBlbWl0KG5leHRSZXN1bHQpIC8vIGVtaXQgZm9yIGltbWVkaWF0ZSBjb25zdW1wdGlvblxuICAgICAgbm9kZVJlc3VsdExpc3QucHVzaChuZXh0UmVzdWx0KVxuICAgICAgaXRlcmF0b3JPYmplY3QgPSBhd2FpdCBub2RlSXRlcmF0b3JGZWVkLm5leHQoKVxuICAgIH1cblxuICAgIHJldHVybiBub2RlUmVzdWx0TGlzdFxuICB9LFxuXG4gIC8qKlxuICAgKiBSYWNlIHByb21pc2Ugb2Ygbm9kZXMgLSBmaXJzdCB0byByZXNvbHZlIGlzIHRoZSBvbmUgdG8gYmUgcmV0dXJuZWRcbiAgICovXG4gIHJhY2VGaXJzdFByb21pc2U6IGFzeW5jIGZ1bmN0aW9uKih7IG5vZGVJdGVyYXRvckZlZWQsIGVtaXQgfSkge1xuICAgIGxldCBub2RlUHJvbWlzZUFycmF5ID0gW11cblxuICAgIGxldCBpdGVyYXRvck9iamVjdCA9IGF3YWl0IG5vZGVJdGVyYXRvckZlZWQubmV4dCgpIC8vIGluaXRpYWxpemUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGV4ZWN1dGlvbiBhbmQgcGFzcyBleGVjdXRpb24gY29uZmlndXJhdGlvbnMuXG4gICAgd2hpbGUgKCFpdGVyYXRvck9iamVjdC5kb25lKSB7XG4gICAgICB5aWVsZCB7IG5vZGU6IGl0ZXJhdG9yT2JqZWN0LnZhbHVlLm5vZGUgfVxuICAgICAgbGV0IHRyYXZlcnNhbFByb21pc2UgPSBmdW5jdGlvbi5zZW50LnRyYXZlcnNhbFByb21pc2VcbiAgICAgIG5vZGVQcm9taXNlQXJyYXkucHVzaCh0cmF2ZXJzYWxQcm9taXNlKVxuICAgICAgaXRlcmF0b3JPYmplY3QgPSBhd2FpdCBub2RlSXRlcmF0b3JGZWVkLm5leHQoKVxuICAgIH1cblxuICAgIGxldCBub2RlUmVzb2x2ZWRSZXN1bHQgPSBhd2FpdCBwcm9taXNlUHJvcGVyUmFjZShub2RlUHJvbWlzZUFycmF5KVxuICAgICAgLnRoZW4ocmVzb2x2ZWRQcm9taXNlQXJyYXkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlQXJyYXlbMF0gLy8gYXMgb25seSBvbmUgcHJvbWlzZSBpcyByZXR1cm4gaW4gdGhlIGFycmF5IC0gdGhlIGZpcnN0IHByb21pc2UgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgLy8gVE9ETzogY2F0Y2ggYWxsIGVycm9yIGFuZCBvdXRwdXQgdGhlbSBmb3IgZWFjaCByZWplY3RlZCBwcm9taXNlLiAoZWRpdCBwcm9taXNlUHJvcGVyUmFjZSBtb2R1bGUpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYPCflIDimqDvuI8gcHJvbWlzZVByb3BlclJhY2UgcmVqZWN0ZWQgYmVjYXVzZTogJHtlcnJvcn1gKVxuICAgICAgfSlcblxuICAgIGlmIChub2RlUmVzb2x2ZWRSZXN1bHQpIHtcbiAgICAgIGVtaXQobm9kZVJlc29sdmVkUmVzdWx0KSAvLyBlbWl0dGluZyByZXN1bHQgaXMgbm90IGltbWVkaWF0ZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgdGhlIG9iamVjdGl2ZSBpcyB0byBnZXQgYSBzaW5nbGUgcmVzb2x2ZWQgcHJvbWlzZSwgYW5kIFwicHJvbWlzZVByb3BlclJhY2VcIiBtYXliZSBkb2Vzbid0IGhhdmUgdGhlIGFiaWxpdHkgdG8gc3RvcCB1bmNvbXBsZXRlZCBwcm9taXNlcy5cbiAgICAgIHJldHVybiBbbm9kZVJlc29sdmVkUmVzdWx0XSAvLyByZXR1cm5lZCByZXN1bHRzIG11c3QgYmUgd3JhcHBlZCBpbiBhcnJheSBzbyBpdCBjb3VsZCBiZSBmb3J3YXJkZWQgdGhyb3VnaCB5ZWlsZCogZ2VuZXJhdG9yLlxuICAgIH0gZWxzZSByZXR1cm4gW11cbiAgfSxcblxuICAvKipcbiAgICogSW5zdXJlcyBhbGwgbm9kZUNvbm5lY3Rpb24gcHJvbWlzZXMgcmVzb2x2ZXMuXG4gICAqKi9cbiAgYWxsUHJvbWlzZTogYXN5bmMgZnVuY3Rpb24qKHsgbm9kZUl0ZXJhdG9yRmVlZCwgZW1pdCB9KSB7XG4gICAgbGV0IG5vZGVQcm9taXNlQXJyYXkgPSBbXSAvLyBvcmRlciBvZiBjYWxsIGluaXRpYWxpemF0aW9uXG4gICAgbGV0IHJlc29sdmVkT3JkZXJlZE5vZGVSZXNvbHZlZFJlc3VsdCA9IFtdIC8vIG9yZGVyIG9mIGNvbXBsZXRpb25cblxuICAgIGxldCBpdGVyYXRvck9iamVjdCA9IGF3YWl0IG5vZGVJdGVyYXRvckZlZWQubmV4dCgpIC8vIGluaXRpYWxpemUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGV4ZWN1dGlvbiBhbmQgcGFzcyBleGVjdXRpb24gY29uZmlndXJhdGlvbnMuXG4gICAgd2hpbGUgKCFpdGVyYXRvck9iamVjdC5kb25lKSB7XG4gICAgICB5aWVsZCB7IG5vZGU6IGl0ZXJhdG9yT2JqZWN0LnZhbHVlLm5vZGUgfVxuICAgICAgbGV0IHRyYXZlcnNhbFByb21pc2UgPSBmdW5jdGlvbi5zZW50LnRyYXZlcnNhbFByb21pc2UudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBlbWl0KHJlc3VsdCkgLy8gZW1pdCByZXN1bHQgZm9yIGltbWVkaWF0ZSB1c2FnZSBieSBsaXNudGVyc1xuICAgICAgICByZXNvbHZlZE9yZGVyZWROb2RlUmVzb2x2ZWRSZXN1bHQucHVzaChyZXN1bHQpIC8vIGFycmF5IG9mIG5vZGUgcHJvY2VzcyByZXN1bHRzLlxuICAgICAgfSkgLy8gYXJyYW5nZSBwcm9taXNlcyBhY2NvcmRpbmcgdG8gcmVzb2x1dGlvbiBvcmRlci5cbiAgICAgIG5vZGVQcm9taXNlQXJyYXkucHVzaCh0cmF2ZXJzYWxQcm9taXNlKSAvLyBwcm9taXNlcyBhcmUgaW4gdGhlIHNhbWUgYXJyYW5nbWVudCBvZiBjb25uZWN0aW9uIGl0ZXJhdGlvbi5cbiAgICAgIGl0ZXJhdG9yT2JqZWN0ID0gYXdhaXQgbm9kZUl0ZXJhdG9yRmVlZC5uZXh0KClcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIGFsbCBwcm9taXNlc1xuICAgIGxldCBub2RlUmVzb2x2ZWRSZXN1bHRBcnJheSA9IGF3YWl0IFByb21pc2UuYWxsKG5vZGVQcm9taXNlQXJyYXkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5TWk5fREVCVUcgPT0gJ3RydWUnKSBjb25zb2xlLmVycm9yKGDwn5SA4pqg77iPIFxcYFByb21pc2UuYWxsXFxgIGZvciBub2RlQ29ubmVjdGlvbkFycmF5IHJlamVjdGVkIGJlY2F1c2U6ICR7ZXJyb3J9YClcbiAgICAgIGVsc2UgY29uc29sZS5sb2coZXJyb3IpXG4gICAgfSlcblxuICAgIC8vIG9yZGVyZWQgcmVzdWx0cyBhY2NvcmRpbmcgdG8gcHJvbWlzZSBjb21wbGV0aW9uLlxuICAgIHJldHVybiByZXNvbHZlZE9yZGVyZWROb2RlUmVzb2x2ZWRSZXN1bHQgLy8gcmV0dXJuIGZvciBhbGwgcmVzb2x2ZWQgcmVzdWx0c1xuXG4gICAgLy8gUHJlc2VydmVzIHRoZSBvcmRlciBvZiBub2RlcyBvcmlnaW5hbCBpbiBjb25uZWN0aW9uIGFycmF5LCBpLmUuIGRvZXMgbm90IG9yZGVyIHRoZSBub2RlIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHRoZSBleGVjdXRpb24gY29tcGxldGlvbiwgcmF0aGVyIGFjY29yZGluZyB0byB0aGUgZmlyc3QgdmlzaXRlZCBkdXJpbmcgdHJhdmVyc2FsLlxuICAgIC8vIGZvciAobGV0IG5leHRSZXN1bHQgb2Ygbm9kZVJlc29sdmVkUmVzdWx0QXJyYXkpIHtcbiAgICAvLyAgIGVtaXQobmV4dFJlc3VsdClcbiAgICAvLyB9XG4gIH0sXG59XG4iXX0=